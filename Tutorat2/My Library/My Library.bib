
@online{noauthor_manjaro_2022,
	title = {manjaro},
	url = {https://wallpapercave.com/w/wp9774690},
	urldate = {2022-01-28},
	date = {2022-01-28},
}

@book{parr_language_2009,
	title = {Language Implementation Patterns: Create Your Own Domain-Specific and General Programming Languages},
	isbn = {978-1-68050-374-6},
	shorttitle = {Language Implementation Patterns},
	abstract = {Learn to build configuration file readers, data readers, model-driven code generators, source-to-source translators, source analyzers, and interpreters. You don't need a background in computer science–{ANTLR} creator Terence Parr demystifies language implementation by breaking it down into the most common design patterns. Pattern by pattern, you'll learn the key skills you need to implement your own computer languages.Knowing how to create domain-specific languages ({DSLs}) can give you a huge productivity boost. Instead of writing code in a general-purpose programming language, you can first build a custom language tailored to make you efficient in a particular domain.The key is understanding the common patterns found across language implementations. Language Design Patterns identifies and condenses the most common design patterns, providing sample implementations of each.The pattern implementations use Java, but the patterns themselves are completely general. Some of the implementations use the well-known {ANTLR} parser generator, so readers will find this book an excellent source of {ANTLR} examples as well. But this book will benefit anyone interested in implementing languages, regardless of their tool of choice. Other language implementation books focus on compilers, which you rarely need in your daily life. Instead, Language Design Patterns shows you patterns you can use for all kinds of language applications.You'll learn to create configuration file readers, data readers, model-driven code generators, source-to-source translators, source analyzers, and interpreters. Each chapter groups related design patterns and, in each pattern, you'll get hands-on experience by building a complete sample implementation. By the time you finish the book, you'll know how to solve most common language implementation problems.},
	pagetotal = {456},
	publisher = {Pragmatic Bookshelf},
	author = {Parr, Terence},
	date = {2009-12-31},
	keywords = {Computers / General, Computers / Programming / Compilers, Computers / Programming / General, Computers / Software Development \& Engineering / General},
	annotation = {Google-Books-{ID}: Ag9QDwAAQBAJ},
}

@online{keith_singleton_2022,
	title = {Singleton Pattern In Python},
	url = {https://stackoverflow.com/questions/52351312/singleton-pattern-in-python},
	author = {{Keith}},
	urldate = {2022-01-28},
	date = {2022-01-28},
}

@book{g_siek_essentials_2022,
	title = {Essentials of Compilation},
	url = {https://iucompilercourse.github.io/IU-Fall-2021/},
	author = {G. Siek, Jeremy},
	urldate = {2022-01-28},
	date = {2022-01-28},
}

@software{drew_othneildrewbest-readme-template_2022,
	title = {othneildrew/Best-{README}-Template},
	url = {https://github.com/othneildrew/Best-README-Template},
	abstract = {An awesome {README} template to jumpstart your projects!},
	author = {Drew, Othneil},
	urldate = {2022-01-28},
	date = {2022-01-28},
	keywords = {readme, readme-template},
	annotation = {Programmers: \_:n19 Programmers: \_:n16 original-date: 2018-12-10T17:56:03Z},
}

@online{noauthor_cmd2indexrst_2022,
	title = {cmd2/index.rst at bef3c758829fe2aa82d58699d61fa78aa961f29d · python-cmd2/cmd2},
	url = {https://github.com/python-cmd2/cmd2},
	abstract = {cmd2 - quickly build feature-rich and user-friendly interactive command line applications in Python - cmd2/index.rst at bef3c758829fe2aa82d58699d61fa78aa961f29d · python-cmd2/cmd2},
	urldate = {2022-01-28},
	date = {2022-01-28},
}

@software{griffiths_scott-griffithsbitstring_2022,
	title = {scott-griffiths/bitstring},
	url = {https://github.com/scott-griffiths/bitstring},
	abstract = {A Python module to help you manage your bits},
	author = {Griffiths, Scott},
	urldate = {2022-01-28},
	date = {2022-01-20},
	keywords = {binary-data, bit-manipulation, bitarray, bitstring, python},
	annotation = {Programmers: \_:n27 Programmers: \_:n24 original-date: 2015-04-11T20:49:04Z},
}

@software{klockner_pudb_2022,
	title = {{PuDB}: a console-based visual debugger for Python},
	url = {https://github.com/inducer/pudb},
	shorttitle = {{PuDB}},
	abstract = {Full-screen console debugger for Python},
	author = {Klöckner, Andreas},
	urldate = {2022-01-28},
	date = {2022-01-25},
	keywords = {python, bpython, debug, debugger, ipython, pdb, pytest, pytest-plugin, urwid},
	annotation = {Programmers: \_:n35 Programmers: \_:n32 original-date: 2011-05-13T23:44:30Z},
}

@software{astanin_python-tabulate_2022,
	title = {python-tabulate},
	url = {https://github.com/astanin/python-tabulate},
	abstract = {Pretty-print tabular data in Python, a library and a command-line utility. Repository migrated from bitbucket.org/astanin/python-tabulate.},
	author = {Astanin, Sergey},
	urldate = {2022-01-28},
	date = {2022-01-26},
	annotation = {Programmers: \_:n47 Programmers: \_:n44 original-date: 2019-09-02T14:34:19Z},
}

@online{noauthor_zotero_2022,
	title = {Zotero {\textbackslash}textbar Your personal research assistant},
	url = {https://www.zotero.org/},
	urldate = {2022-01-28},
	date = {2022-01-28},
}

@software{reinhart_jonathonreinhartstaticx_2022,
	title = {{JonathonReinhart}/staticx},
	url = {https://github.com/JonathonReinhart/staticx},
	abstract = {Create static executable from dynamic executable},
	author = {Reinhart, Jonathon},
	urldate = {2022-01-28},
	date = {2022-01-23},
	annotation = {Programmers: \_:n53 original-date: 2017-05-27T18:37:54Z},
}

@online{noauthor_faq_2022,
	title = {{FAQ} · pyinstaller/pyinstaller Wiki},
	url = {https://github.com/pyinstaller/pyinstaller},
	abstract = {Freeze (package) Python programs into stand-alone executables - {FAQ} · pyinstaller/pyinstaller Wiki},
	urldate = {2022-01-28},
	date = {2022-01-28},
}

@online{noauthor_releases_2022,
	title = {Releases · jgraph/drawio-desktop},
	url = {https://github.com/jgraph/drawio-desktop/releases},
	abstract = {Official electron build of diagrams.net. Contribute to jgraph/drawio-desktop development by creating an account on {GitHub}.},
	urldate = {2022-01-28},
	date = {2022-01-28},
}

@online{noauthor_github_2022,
	title = {{GitHub} - marp-team/marp-cli: A {CLI} interface for Marp and Marpit based converters},
	url = {https://github.com/marp-team/marp-cli},
	urldate = {2022-01-28},
	date = {2022-01-28},
}

@software{noauthor_pyinstaller_2022,
	title = {{PyInstaller} Overview},
	url = {https://github.com/pyinstaller/pyinstaller},
	abstract = {Freeze (package) Python programs into stand-alone executables},
	publisher = {{PyInstaller}},
	urldate = {2022-01-28},
	date = {2022-01-28},
	keywords = {python, bundle, package, py2app, py2exe, pyinstaller, python-3, python-to-exe},
	annotation = {original-date: 2011-11-23T11:05:56Z},
}

@online{noauthor_running_2020,
	title = {Running a bash script - Code to Cloud / {GitHub} Actions},
	url = {https://github.community/t/running-a-bash-script/141584/2},
	abstract = {With that setup the path to the script is relative to the root of your repository, so if your script is .github/script.sh that’s all that’s needed in the run step. Remember that the file must be marked as executable, or you need to explicitly call bash with the script as parameter.},
	urldate = {2022-04-11},
	date = {2020-11-04},
	file = {Snapshot:files/24/2.html:text/html;Snapshot:files/85/2.html:text/html},
}

@software{noauthor_actionsstarter-workflows_2022,
	title = {actions/starter-workflows},
	url = {https://github.com/actions/starter-workflows/blob/70f16d3552b2b728227019eb69710ed1b44cf811/ci/python-package.yml},
	abstract = {Accelerating new {GitHub} Actions workflows},
	publisher = {{GitHub} Actions},
	urldate = {2022-04-11},
	date = {2022-04-11},
	annotation = {original-date: 2019-07-29T16:26:51Z},
}

@inreference{noauthor_identifier_2022,
	title = {Identifier (computer languages)},
	url = {https://en.wikipedia.org/w/index.php?title=Identifier_(computer_languages)&oldid=1081115854},
	abstract = {In computer programming languages, an identifier is a lexical token (also called a symbol, but not to be confused with the symbol primitive data type) that names the language's entities. Some of the kinds of entities an identifier might denote include variables, data types, labels, subroutines, and modules.},
	booktitle = {Wikipedia},
	urldate = {2022-04-13},
	date = {2022-04-05},
	annotation = {Page Version {ID}: 1081115854},
	file = {Snapshot:files/29/Identifier_(computer_languages).html:text/html;Snapshot:files/88/Identifier_(computer_languages).html:text/html},
}

@online{ljohhuh_what_2018,
	title = {What is an immediate value?},
	url = {https://reverseengineering.stackexchange.com/q/17671},
	author = {{Ljohhuh}},
	urldate = {2022-04-13},
	date = {2018-04-04},
	file = {Snapshot:files/31/what-is-an-immediate-value.html:text/html;Snapshot:files/90/what-is-an-immediate-value.html:text/html},
}

@online{skochinsky_answer_2018,
	title = {Answer to "What is an immediate value?"},
	url = {https://reverseengineering.stackexchange.com/a/17678},
	shorttitle = {Answer to "What is an immediate value?},
	author = {Skochinsky, Igor},
	urldate = {2022-04-13},
	date = {2018-03-13},
	file = {Snapshot:files/33/what-is-an-immediate-value.html:text/html;Snapshot:files/92/what-is-an-immediate-value.html:text/html},
}

@online{noauthor_qualifiers_2020,
	title = {Qualifiers in C [ Size, Sign and Type Qualifiers in Detail ]},
	url = {https://learnprogramo.com/qualifiers-in-c-9/},
	abstract = {Qualifiers in C. The Qualifiers are the keywords which are applied to the data types. There are three types of qualifiers in C. 1.Type Qualifiers 2.Size Qua},
	urldate = {2022-04-13},
	date = {2020-05-18},
	annotation = {Section: Tutorials},
	file = {Snapshot:files/36/qualifiers-in-c-9.html:text/html;Snapshot:files/94/qualifiers-in-c-9.html:text/html},
}

@online{noauthor_pep_nodate,
	title = {{PEP} 20 – The Zen of Python {\textbackslash}textbar peps.python.org},
	url = {https://peps.python.org/pep-0020/#id3},
	urldate = {2022-04-13},
	file = {PEP 20 – The Zen of Python | peps.python.org:files/38/pep-0020.html:text/html},
}

@article{earley_formalism_1970,
	title = {A formalism for translator interactions},
	doi = {10.1145/355598.362740},
	abstract = {A formalism is presented for describing the actions of processors for programming languages—compilers, interpreters, assemblers—and their interactions in complex systems such as compiler-compilers or extendible languages. The formalism here might be used to define and answer such a question as “Can one do bootstrapping using a metacompiler whose metaphase is interpretive?” In addition an algorithm is presented for deciding whether or not a given system can be produced from a given set of component processors.},
	journaltitle = {{CACM}},
	author = {Earley, J. and Sturgis, Howard E.},
	date = {1970},
}

@online{noauthor_c_nodate,
	title = {C Operator Precedence - cppreference.com},
	url = {https://en.cppreference.com/w/c/language/operator_precedence},
	urldate = {2022-04-27},
	file = {C Operator Precedence - cppreference.com:files/41/operator_precedence.html:text/html;C Operator Precedence - cppreference.com:files/99/operator_precedence.html:text/html},
}

@online{noauthor_lecture-notes-2021_2022,
	title = {lecture-notes-2021},
	url = {https://github.com/Compiler-Construction-Uni-Freiburg/lecture-notes-2021/blob/56300e6649e32f0594bbbd046a2e19351c57dd0c/material/lexical-analysis.pdf},
	urldate = {2022-04-28},
	date = {2022-01-20},
	annotation = {original-date: 2021-10-19T12:38:11Z},
}

@software{noauthor_neovim_2022,
	title = {Neovim Treesitter Playground},
	url = {https://github.com/nvim-treesitter/playground},
	abstract = {Treesitter playground integrated into Neovim},
	publisher = {nvim-treesitter},
	urldate = {2022-05-03},
	date = {2022-05-03},
	keywords = {hacktoberfest, neovim, nvim-treesitter, tree-sitter},
	annotation = {original-date: 2020-07-23T13:07:27Z},
}

@software{noauthor_nvim-treesitter_2022,
	title = {nvim-treesitter},
	url = {https://github.com/nvim-treesitter/nvim-treesitter},
	abstract = {Nvim Treesitter configurations and abstraction layer},
	publisher = {nvim-treesitter},
	urldate = {2022-05-03},
	date = {2022-05-03},
	keywords = {hacktoberfest, neovim, nvim-treesitter, tree-sitter},
	annotation = {original-date: 2020-04-18T15:24:10Z},
}

@online{margus_answer_2011,
	title = {Answer to "Iterating over every two elements in a list"},
	url = {https://stackoverflow.com/a/5389578},
	author = {{Margus}},
	urldate = {2022-05-03},
	date = {2011-03-22},
}

@online{awesoon_answer_2013,
	title = {Answer to "why const char *pt2=\{'1', '2', '3', '{\textbackslash}textbackslash0'\}; can't compile?"},
	url = {https://stackoverflow.com/a/16808070},
	shorttitle = {Answer to "why const char *pt2=\{'1', '2', '3', '{\textbackslash}textbackslash0'\}; can't compile?},
	author = {{awesoon}},
	urldate = {2022-05-07},
	date = {2013-05-29},
	file = {Snapshot:files/54/why-const-char-pt2-1-2-3-0-cant-compile.html:text/html},
}

@online{lindley_answer_2013,
	title = {Answer to "Assign array to array"},
	url = {https://stackoverflow.com/a/18962507},
	author = {Lindley, Benjamin},
	urldate = {2022-05-07},
	date = {2013-09-23},
}

@online{blckknght_answer_2016,
	title = {Answer to "What is a pythonic way of slicing a set?"},
	url = {https://stackoverflow.com/a/40737853},
	shorttitle = {Answer to "What is a pythonic way of slicing a set?},
	author = {{Blckknght}},
	urldate = {2022-05-09},
	date = {2016-11-22},
	file = {Snapshot:files/57/what-is-a-pythonic-way-of-slicing-a-set.html:text/html;Snapshot:files/110/what-is-a-pythonic-way-of-slicing-a-set.html:text/html},
}

@online{noauthor_errors_nodate,
	title = {Errors in C/C++ - {GeeksforGeeks}},
	url = {https://www.geeksforgeeks.org/errors-in-cc/},
	urldate = {2022-05-10},
}

@online{mahajan_scaler_2022,
	title = {Scaler Topics},
	url = {https://www.scaler.com/topics/c/types-of-errors-in-c/},
	abstract = {This article by Scaler Topics explains errors \& their types in C, covering the explanation \& examples for each type of error in C Programming Language.},
	author = {Mahajan, Urvish},
	urldate = {2022-05-10},
	date = {2022-01-28},
	file = {Snapshot:files/62/types-of-errors-in-c.html:text/html;Snapshot:files/114/types-of-errors-in-c.html:text/html},
}

@online{noauthor_visual_nodate,
	title = {visual c++ - Where can I get a list of all errors \& warnings? - Stack Overflow},
	url = {https://stackoverflow.com/questions/1392855/where-can-i-get-a-list-of-all-errors-warnings},
	urldate = {2022-05-10},
	file = {visual c++ - Where can I get a list of all errors & warnings? - Stack Overflow:files/64/where-can-i-get-a-list-of-all-errors-warnings.html:text/html;visual c++ - Where can I get a list of all errors & warnings? - Stack Overflow:files/116/where-can-i-get-a-list-of-all-errors-warnings.html:text/html},
}

@online{noauthor_what_nodate,
	title = {What is the difference between a token and a lexeme?},
	url = {http://newbedev.com/what-is-the-difference-between-a-token-and-a-lexeme},
	abstract = {Using "Compilers Principles, Techniques, \& Tools, 2nd Ed." ({WorldCat}) by Aho, Lam, Sethi and Ullman, {AKA} the Purple Dragon Book, Lexeme pg. 111 A lexeme is a se},
	titleaddon = {{NewbeDEV}},
	urldate = {2022-06-17},
	langid = {american},
	file = {Snapshot:files/66/what-is-the-difference-between-a-token-and-a-lexeme.html:text/html;Snapshot:files/118/what-is-the-difference-between-a-token-and-a-lexeme.html:text/html},
}

@online{noauthor_zotero_2022-1,
	title = {Zotero {\textbackslash}textbackslashtextbar Your personal research assistant},
	url = {https://www.zotero.org/},
	urldate = {2022-01-28},
	date = {2022-01-28},
}

@online{noauthor_pep_nodate-1,
	title = {{PEP} 20 – The Zen of Python {\textbackslash}textbackslashtextbar peps.python.org},
	url = {https://peps.python.org/pep-0020/#id3},
	urldate = {2022-04-13},
	file = {PEP 20 – The Zen of Python | peps.python.org:files/96/pep-0020.html:text/html},
}

@software{noauthor_lark_2022,
	title = {Lark - a parsing toolkit for Python},
	url = {https://github.com/lark-parser/lark},
	abstract = {Lark is a parsing toolkit for Python, built with a focus on ergonomics, performance and modularity.},
	publisher = {Lark - Parsing Library \& Toolkit},
	urldate = {2022-04-28},
	date = {2022-04-26},
	keywords = {python, cyk, earley, grammar, lalr, lark, parse, parser, parser-library, parsing-engine, parsing-library, tree},
}

@online{awesoon_answer_2013-1,
	title = {Answer to "why const char *pt2=\{'1', '2', '3', '{\textbackslash}textbackslashtextbackslash0'\}; can't compile?"},
	url = {https://stackoverflow.com/a/16808070},
	shorttitle = {Answer to "why const char *pt2=\{'1', '2', '3', '{\textbackslash}textbackslashtextbackslash0'\}; can't compile?},
	author = {{awesoon}},
	urldate = {2022-05-07},
	date = {2013-05-29},
	file = {Snapshot:files/107/why-const-char-pt2-1-2-3-0-cant-compile.html:text/html},
}

@online{noauthor_compiler_nodate,
	title = {Compiler Design - Phases of Compiler},
	url = {https://www.tutorialspoint.com/compiler_design/compiler_design_phases_of_compiler.htm},
	urldate = {2022-06-19},
}

@online{noauthor_earley_nodate,
	title = {Earley Parser},
	url = {https://rahul.gopinath.org/post/2021/02/06/earley-parsing/},
	urldate = {2022-06-20},
}

@online{noauthor_parsers_nodate,
	title = {Parsers — Lark documentation},
	url = {https://lark-parser.readthedocs.io/en/latest/parsers.html},
	urldate = {2022-06-20},
	file = {Parsers — Lark documentation:files/122/parsers.html:text/html},
}

@online{noauthor_what_nodate-1,
	title = {What is Bottom-up Parsing?},
	url = {https://www.tutorialspoint.com/what-is-bottom-up-parsing},
	urldate = {2022-06-22},
	file = {What is Bottom-up Parsing?:files/124/what-is-bottom-up-parsing.html:text/html},
}

@online{noauthor_what_nodate-2,
	title = {What is Top-Down Parsing?},
	url = {https://www.tutorialspoint.com/what-is-top-down-parsing},
	urldate = {2022-06-22},
	file = {What is Top-Down Parsing?:files/126/what-is-top-down-parsing.html:text/html},
}

@online{noauthor_what_nodate-3,
	title = {What is a Bootstrap? - Definition from Techopedia},
	url = {http://www.techopedia.com/definition/3328/bootstrap},
	shorttitle = {What is a Bootstrap?},
	abstract = {This definition explains the meaning of Bootstrap and why it matters.},
	titleaddon = {Techopedia.com},
	urldate = {2022-06-27},
	langid = {english},
}

@online{skochinsky_answer_2018-1,
	title = {Answer to "What is an immediate value?"},
	url = {https://reverseengineering.stackexchange.com/a/17678},
	shorttitle = {Answer to "What is an immediate value?},
	titleaddon = {Reverse Engineering Stack Exchange},
	author = {Skochinsky, Igor},
	urldate = {2022-06-28},
	date = {2018-03-13},
}

@unpublished{thiemann_einfuhrung_2018,
	location = {Universität Freiburg},
	title = {Einführung in die Programmierung},
	url = {http://proglang.informatik.uni-freiburg.de/teaching/info1/2018/},
	type = {Vorlesung},
	howpublished = {Vorlesung},
	author = {Thiemann, Peter},
	urldate = {2022-07-09},
	date = {2018},
}

@unpublished{scholl_einfuhrung_2021,
	location = {Universität Freiburg},
	title = {Einführung in Embedded Systems},
	url = {https://earth.informatik.uni-freiburg.de/uploads/es-2122/},
	type = {Vorlesung},
	howpublished = {Vorlesung},
	author = {Scholl, Philipp},
	urldate = {2022-07-09},
	date = {2021},
}

@unpublished{thiemann_compilerbau_2021,
	location = {Universität Freiburg},
	title = {Compilerbau},
	url = {http://proglang.informatik.uni-freiburg.de/teaching/compilerbau/2021ws/},
	type = {Vorlesung},
	howpublished = {Vorlesung},
	author = {Thiemann, Peter},
	urldate = {2022-07-09},
	date = {2021},
}

@unpublished{bast_programmieren_2020,
	location = {Universität Freiburg},
	title = {Programmieren in C},
	url = {https://ad-wiki.informatik.uni-freiburg.de/teaching/ProgrammierenCplusplusSS2020},
	type = {Vorlesung},
	howpublished = {Vorlesung},
	author = {Bast, Hannah},
	urldate = {2022-07-09},
	date = {2020},
}

@unpublished{scholl_betriebssysteme_2020,
	location = {Universität Freiburg},
	title = {Betriebssysteme},
	url = {https://abs.informatik.uni-freiburg.de/src/teach_main.php?id=157},
	type = {Vorlesung},
	howpublished = {Vorlesung},
	author = {Scholl, Christoph},
	urldate = {2022-07-09},
	date = {2020},
}

@unpublished{nebel_theoretische_2020,
	location = {Universität Freiburg},
	title = {Theoretische Informatik},
	url = {http://gki.informatik.uni-freiburg.de/teaching/ss20/info3/index_de.html},
	type = {Vorlesung},
	howpublished = {Vorlesung},
	author = {Nebel, Bernhard},
	urldate = {2022-07-09},
	date = {2020},
}

@book{nystrom_parsing_2021,
	title = {Parsing Expressions · Crafting Interpreters},
	url = {https://www.craftinginterpreters.com/parsing-expressions.html},
	publisher = {Genever Benning},
	author = {Nystrom, Robert},
	urldate = {2022-07-09},
	date = {2021},
}

@online{noauthor_json_nodate,
	title = {{JSON} parser - Tutorial — Lark documentation},
	url = {https://lark-parser.readthedocs.io/en/latest/json_tutorial.html},
	urldate = {2022-07-09},
	file = {JSON parser - Tutorial — Lark documentation:files/137/json_tutorial.html:text/html},
}

@online{noauthor_transformers_nodate,
	title = {Transformers \& Visitors — Lark documentation},
	url = {https://lark-parser.readthedocs.io/en/latest/visitors.html},
	urldate = {2022-07-09},
	file = {Transformers & Visitors — Lark documentation:files/139/visitors.html:text/html},
}

@online{noauthor_gcc_nodate,
	title = {{GCC}, the {GNU} Compiler Collection - {GNU} Project},
	url = {https://gcc.gnu.org/},
	urldate = {2022-07-13},
}

@online{noauthor_gdb_nodate,
	title = {{GDB}: The {GNU} Project Debugger},
	url = {https://www.sourceware.org/gdb/},
	urldate = {2022-07-13},
}

@online{noauthor_baume_nodate,
	title = {Bäume},
	url = {https://www.stefan-marr.de/pages/informatik-abivorbereitung/baume/},
	urldate = {2022-07-17},
	langid = {german},
}

@online{neelam_what_2014,
	title = {What is the difference between function signature and function prototype?},
	url = {https://www.queryhome.com/tech/48466/difference-between-function-signature-function-prototype},
	abstract = {What is the difference between function signature and function prototype?},
	titleaddon = {{QueryHome}},
	author = {Neelam},
	urldate = {2022-07-18},
	date = {2014-06-22},
	langid = {american},
	file = {Snapshot:files/144/difference-between-function-signature-function-prototype.html:text/html},
}

@online{noauthor_what_nodate-4,
	title = {What is the difference between function prototype and function signature?},
	url = {https://www.sololearn.com/Discuss/171026/what-is-the-difference-between-function-prototype-and-function-signature/},
	abstract = {Check out what Vaibhav kumar has posted on {SoloLearn}},
	titleaddon = {{SoloLearn}},
	urldate = {2022-07-18},
	langid = {english},
	file = {Snapshot:files/146/what-is-the-difference-between-function-prototype-and-function-signature.html:text/html},
}

@unpublished{westphal_softwaretechnik_2021,
	location = {Universität Freiburg},
	title = {Softwaretechnik},
	url = {https://swt.informatik.uni-freiburg.de/teaching/SS2021/swtvl},
	type = {Vorlesung},
	howpublished = {Vorlesung},
	author = {Westphal, Dr. Bernd},
	urldate = {2022-07-19},
	date = {2021},
}

@inproceedings{bolingbroke_types_2009,
	location = {Edinburgh, Scotland},
	title = {Types are calling conventions},
	isbn = {978-1-60558-508-6},
	url = {http://portal.acm.org/citation.cfm?doid=1596638.1596640},
	doi = {10.1145/1596638.1596640},
	abstract = {It is common for compilers to derive the calling convention of a function from its type. Doing so is simple and modular but misses many optimisation opportunities, particularly in lazy, higher-order functional languages with extensive use of currying. We restore the lost opportunities by deﬁning Strict Core, a new intermediate language whose type system makes the missing distinctions: laziness is explicit, and functions take multiple arguments and return multiple results.},
	eventtitle = {the 2nd {ACM} {SIGPLAN} symposium},
	pages = {1},
	booktitle = {Proceedings of the 2nd {ACM} {SIGPLAN} symposium on Haskell - Haskell '09},
	publisher = {{ACM} Press},
	author = {Bolingbroke, Maximilian C. and Peyton Jones, Simon L.},
	urldate = {2022-07-23},
	date = {2009},
	langid = {english},
	file = {Bolingbroke and Peyton Jones - 2009 - Types are calling conventions.pdf:files/148/Bolingbroke and Peyton Jones - 2009 - Types are calling conventions.pdf:application/pdf},
}

@online{noauthor_-normalization_nodate,
	title = {A-Normalization: Why and How (with code)},
	url = {https://matt.might.net/articles/a-normalization/},
	urldate = {2022-07-23},
}

@online{noauthor_duden_nodate,
	title = {Duden {\textbar} Patch {\textbar} Rechtschreibung, Bedeutung, Definition, Herkunft},
	url = {https://www.duden.de/rechtschreibung/Patch_Software_Programm},
	abstract = {Definition, Rechtschreibung, Synonyme und Grammatik von 'Patch' auf Duden online nachschlagen. Wörterbuch der deutschen Sprache.},
	urldate = {2022-07-23},
	langid = {german},
	file = {Snapshot:files/152/Patch_Software_Programm.html:text/html},
}

@online{noauthor_ansi_nodate,
	title = {{ANSI} C grammar (Yacc)},
	url = {http://www.quut.com/c/ANSI-C-grammar-y.html},
	urldate = {2022-07-29},
	file = {ANSI C grammar (Yacc):files/154/ANSI-C-grammar-y.html:text/html;ANSI C grammar (Yacc):files/204/ANSI-C-grammar-y.html:text/html},
}

@online{noauthor_ansi_nodate-1,
	title = {{ANSI} C grammar (Lex)},
	url = {https://www.lysator.liu.se/c/ANSI-C-grammar-l.html},
	urldate = {2022-07-29},
	file = {ANSI C grammar (Lex):files/158/ANSI-C-grammar-l.html:text/html;ANSI C grammar (Lex):files/203/ANSI-C-grammar-l.html:text/html},
}

@online{noauthor_clang_nodate,
	title = {clang: C++ Compiler},
	url = {http://clang.org/},
	urldate = {2022-07-29},
}

@online{noauthor_clockwisespiral_nodate,
	title = {Clockwise/Spiral Rule},
	url = {https://c-faq.com/decl/spiral.anderson.html},
	urldate = {2022-07-29},
}

@online{noauthor_grammar_nodate,
	title = {Grammar: The language of languages ({BNF}, {EBNF}, {ABNF} and more)},
	url = {https://matt.might.net/articles/grammars-bnf-ebnf/},
	urldate = {2022-07-30},
}

@inreference{noauthor_naming_2022,
	title = {Naming convention (programming)},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=Naming_convention_(programming)&oldid=1100066005},
	abstract = {In computer programming, a naming convention is a set of rules for choosing the character sequence to be used for identifiers which denote variables, types, functions, and other entities in source code and documentation.
Reasons for using a naming convention (as opposed to allowing programmers to choose any character sequence) include the following:

To reduce the effort needed to read and understand source code;
To enable code reviews to focus on issues more important than syntax and naming standards.
To enable code quality review tools to focus their reporting mainly on significant issues other than syntax and style preferences.The choice of naming conventions can be an enormously controversial issue, with partisans of each holding theirs to be the best and others to be inferior. Colloquially, this is said to be a matter of dogma. Many companies have also established their own set of conventions.},
	booktitle = {Wikipedia},
	urldate = {2022-07-30},
	date = {2022-07-24},
	langid = {english},
	note = {Page Version {ID}: 1100066005},
	file = {Snapshot:files/163/Naming_convention_(programming).html:text/html},
}

@inreference{noauthor_syntax_2022,
	title = {Syntax},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wiktionary.org/w/index.php?title=Syntax&oldid=9196998},
	booktitle = {Wiktionary},
	urldate = {2022-07-31},
	date = {2022-06-07},
	langid = {german},
	note = {Page Version {ID}: 9196998},
}

@inreference{noauthor_backusnaur_2022,
	title = {Backus–Naur form},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=Backus%E2%80%93Naur_form&oldid=1093258638},
	abstract = {In computer science, Backus–Naur form () or Backus normal form ({BNF}) is a metasyntax notation for context-free grammars, often used to describe the syntax of languages used in computing, such as computer programming languages, document formats, instruction sets and communication protocols. They are applied wherever exact descriptions of languages are needed: for instance, in official language specifications, in manuals, and in textbooks on programming language theory.
Many extensions and variants of the original Backus–Naur notation are used; some are exactly defined, including extended Backus–Naur form ({EBNF}) and augmented Backus–Naur form ({ABNF}).},
	booktitle = {Wikipedia},
	urldate = {2022-07-31},
	date = {2022-06-15},
	langid = {english},
	note = {Page Version {ID}: 1093258638},
	file = {Snapshot:files/167/Backus–Naur_form.html:text/html},
}

@inreference{noauthor_extended_2022,
	title = {Extended Backus–Naur form},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=Extended_Backus%E2%80%93Naur_form&oldid=1093574831},
	abstract = {In computer science, extended Backus–Naur form ({EBNF}) is a family of metasyntax notations, any of which can be used to express a context-free grammar.  {EBNF} is used to make a formal description of a formal language such as a computer programming language. They are extensions of the basic Backus–Naur form ({BNF}) metasyntax notation.
The earliest {EBNF} was developed by Niklaus Wirth incorporating some of the concepts (with a different syntax and notation) from Wirth syntax notation. However, many variants of {EBNF} are in use. The International Organization for Standardization adopted an {EBNF} standard ({ISO}/{IEC} 14977) in 1996.
However, according to Zaytsev this standard "only ended up adding yet another three dialects to the chaos" and, after noting its lack of success, also notes that the {ISO} {EBNF} is not even used in all {ISO} standards. Wheeler argues against using the {ISO} standard when using an {EBNF}, and recommends considering alternative {EBNF} notations such as the one from the W3C Extensible Markup Language ({XML}) 1.0 (Fifth Edition).
This article uses {EBNF} as specified by the {ISO} for examples applying to all {EBNFs}. Other {EBNF} variants use somewhat different syntactic conventions.},
	booktitle = {Wikipedia},
	urldate = {2022-07-31},
	date = {2022-06-17},
	langid = {english},
	note = {Page Version {ID}: 1093574831},
	file = {Snapshot:files/168/Extended_Backus–Naur_form.html:text/html},
}

@software{shinan_lark_nodate,
	title = {lark: a modern parsing library},
	rights = {{MIT} License},
	url = {https://github.com/lark-parser/lark},
	shorttitle = {lark},
	version = {1.1.2},
	author = {Shinan, Erez},
	urldate = {2022-07-31},
	keywords = {ast, Earley,, {LALR},, parser,, parsing,, Software Development - Libraries - Python Modules, Text Processing - General, Text Processing - Linguistic},
}

@online{noauthor_grammar_nodate-1,
	title = {Grammar Reference — Lark documentation},
	url = {https://lark-parser.readthedocs.io/en/latest/grammar.html},
	urldate = {2022-07-31},
}

@online{noauthor_antlr_nodate,
	title = {{ANTLR}},
	url = {https://www.antlr.org/},
	urldate = {2022-07-31},
	file = {ANTLR:files/172/www.antlr.org.html:text/html},
}

@online{noauthor_welcome_nodate,
	title = {Welcome to Lark’s documentation! — Lark documentation},
	url = {https://lark-parser.readthedocs.io/en/latest/},
	urldate = {2022-07-31},
	file = {Welcome to Lark’s documentation! — Lark documentation:files/175/latest.html:text/html},
}

@online{noauthor_publicly_nodate,
	title = {Publicly Available Standards},
	url = {https://standards.iso.org/ittf/PubliclyAvailableStandards/},
	urldate = {2022-07-31},
	file = {Publicly Available Standards:files/177/PubliclyAvailableStandards.html:text/html},
}

@unpublished{scholl_technische_2022,
	location = {Universität Freiburg},
	title = {Technische Informatik},
	type = {Vorlesung},
	howpublished = {Vorlesung},
	author = {Scholl, Christoph},
	urldate = {2022-08-03},
	date = {2022-08-03},
}

@software{ueda_makefile_2022,
	title = {Makefile for {LaTeX}},
	rights = {{MIT}},
	url = {https://github.com/tueda/makefile4latex},
	abstract = {A {GNU} Makefile for typesetting {LaTeX} documents.},
	author = {Ueda, Takahiro},
	urldate = {2022-08-03},
	date = {2022-05-10},
	note = {original-date: 2018-07-06T15:01:24Z},
}

@software{nemec_copy_file_to_another_repo_action_2022,
	title = {copy\_file\_to\_another\_repo\_action},
	rights = {Apache-2.0},
	url = {https://github.com/dmnemec/copy_file_to_another_repo_action},
	abstract = {This {GitHub} Action copies a file from the current repository to a location in another repository},
	author = {Nemec, Devin},
	urldate = {2022-08-03},
	date = {2022-07-27},
	note = {original-date: 2020-08-24T19:25:58Z},
	keywords = {hacktoberfest},
}

@online{developers_draw_nodate,
	title = {Draw Freely {\textbar} Inkscape},
	url = {https://inkscape.org/},
	abstract = {Inkscape is professional quality vector graphics software which runs on Linux, Mac {OS} X and Windows desktop computers.},
	author = {Developers, Inkscape Website},
	urldate = {2022-08-03},
	langid = {english},
	file = {Snapshot:files/182/inkscape.org.html:text/html},
}

@book{lefever_art_2012,
	edition = {1},
	title = {The Art of Explanation: Making your Ideas, Products, and Services Easier to Understand},
	shorttitle = {The Art of Explanation},
	publisher = {Wiley},
	author = {{LeFever}, Lee},
	date = {2012-11-20},
}

@online{noauthor_home_nodate,
	title = {Home - Neovim},
	url = {http://neovim.io/},
	urldate = {2022-08-04},
}

@online{noauthor_history_nodate,
	title = {History - {GCC} Wiki},
	url = {https://gcc.gnu.org/wiki/History},
	urldate = {2022-08-06},
	file = {History - GCC Wiki:files/186/History.html:text/html},
}

@online{noauthor_what_2021,
	title = {What is Spilling},
	url = {https://www.geeksforgeeks.org/what-is-spilling/},
	abstract = {A Computer Science portal for geeks. It contains well written, well thought and well explained computer science and programming articles, quizzes and practice/competitive programming/company interview Questions.},
	titleaddon = {{GeeksforGeeks}},
	urldate = {2022-08-07},
	date = {2021-08-01},
	langid = {english},
	note = {Section: Computer Organization \& Architecture},
	file = {Snapshot:files/188/what-is-spilling.html:text/html},
}

@article{earley_efiicient_1968,
	title = {An efiicient context-free parsing},
	volume = {13},
	url = {https://web.archive.org/web/20040708052627/http://www-2.cs.cmu.edu/afs/cs.cmu.edu/project/cmt-55/lti/Courses/711/Class-notes/p94-earley.pdf},
	author = {Earley, Jay},
	urldate = {2022-08-10},
	date = {1968},
	file = {PDF Snapshot:files/190/2004 - Wayback Machine.pdf:application/pdf},
}

@online{noauthor_earley_nodate-1,
	title = {Earley Parser},
	url = {https://rahul.gopinath.org/post/2021/02/06/earley-parsing/},
	urldate = {2022-08-10},
	file = {Earley Parser:files/192/earley-parsing.html:text/html},
}

@online{noauthor_variablen_nodate,
	title = {Variablen in C und C++, Deklaration und Definition {\textbar} Coder-Welten.de},
	url = {https://www.coder-welten.de/einstieg/variablen-in-c-3.html},
	urldate = {2022-08-11},
	file = {Variablen in C und C++, Deklaration und Definition | Coder-Welten.de:files/194/variablen-in-c-3.html:text/html},
}

@inreference{noauthor_earley_2022,
	title = {Earley parser},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=Earley_parser&oldid=1090848932},
	abstract = {In computer science, the Earley parser is an algorithm for parsing strings that belong to a given context-free language, though (depending on the variant) it may suffer problems with certain nullable grammars. The algorithm, named after its inventor, Jay Earley, is a chart parser that uses dynamic programming; it is mainly used for parsing in computational linguistics. It was first introduced in his dissertation in 1968 (and later appeared in an abbreviated, more legible, form in a journal).
Earley parsers are appealing because they can parse all context-free languages, unlike {LR} parsers and {LL} parsers, which are more typically used in compilers but which can only handle restricted classes of languages.  The Earley parser executes in cubic time in the general case 
  
    
      
        
          O
        
        (
        
          n
          
            3
          
        
        )
      
    
    \{{\textbackslash}displaystyle \{O\}(n{\textasciicircum}\{3\})\}
  , where n is the length of the parsed string, quadratic time for unambiguous grammars 
  
    
      
        
          O
        
        (
        
          n
          
            2
          
        
        )
      
    
    \{{\textbackslash}displaystyle \{O\}(n{\textasciicircum}\{2\})\}
  , and linear time for all deterministic context-free grammars. It performs particularly well when the rules are written left-recursively.},
	booktitle = {Wikipedia},
	urldate = {2022-08-15},
	date = {2022-05-31},
	langid = {english},
	note = {Page Version {ID}: 1090848932},
}

@online{noauthor_ansi_nodate-2,
	title = {{ANSI} C grammar (Yacc)},
	url = {https://www.quut.com/c/ANSI-C-grammar-y.html},
	urldate = {2022-08-15},
	file = {ANSI C grammar (Yacc):files/206/ANSI-C-grammar-y.html:text/html},
}

@online{noauthor_ansi_nodate-3,
	title = {{ANSI} C grammar (Yacc) old},
	url = {https://www.lysator.liu.se/c/ANSI-C-grammar-y.html},
	urldate = {2022-08-15},
	file = {ANSI C grammar (Yacc):files/209/ANSI-C-grammar-y.html:text/html},
}

@online{noauthor_ansi_nodate-4,
	title = {{ANSI} C grammar (Lex)},
	url = {https://www.quut.com/c/ANSI-C-grammar-l-2011.html},
	urldate = {2022-08-15},
	file = {ANSI C grammar (Lex):files/211/ANSI-C-grammar-l-2011.html:text/html},
}

@online{noauthor_ansi_nodate-5,
	title = {{ANSI} C grammar (Lex) old},
	url = {https://www.lysator.liu.se/c/ANSI-C-grammar-l.html},
	urldate = {2022-08-15},
	file = {ANSI C grammar (Lex):files/212/ANSI-C-grammar-l.html:text/html},
}

@inreference{noauthor_pipes_2021,
	title = {Pipes und Filter},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Pipes_und_Filter&oldid=213086457},
	abstract = {Pipes und Filter (engl. pipes-and-filters, auch Datenfluss-System) ist ein Architekturmuster aus dem Bereich der Softwareentwicklung. Es beschreibt die Struktur für Systeme, die Datenströme verarbeiten.},
	booktitle = {Wikipedia},
	urldate = {2022-09-04},
	date = {2021-06-18},
	langid = {german},
	note = {Page Version {ID}: 213086457},
}

@online{noauthor_217_nodate,
	title = {2.1.7 Vorrangregeln und Assoziativität},
	url = {https://www.tu-chemnitz.de/urz/archiv/kursunterlagen/C/kap2/vorrang.htm},
	urldate = {2022-09-05},
	file = {2.1.7 Vorrangregeln und Assoziativität:files/215/vorrang.html:text/html},
}

@inreference{noauthor_pipes_2021-1,
	title = {Pipes und Filter},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Pipes_und_Filter&oldid=213086457},
	abstract = {Pipes und Filter (engl. pipes-and-filters, auch Datenfluss-System) ist ein Architekturmuster aus dem Bereich der Softwareentwicklung. Es beschreibt die Struktur für Systeme, die Datenströme verarbeiten.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2021-06-18},
	langid = {german},
	note = {Page Version {ID}: 213086457},
	file = {Snapshot:files/217/Pipes_und_Filter.html:text/html},
}

@inreference{noauthor_imperative_2022,
	title = {Imperative Programmierung},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Imperative_Programmierung&oldid=219505017},
	abstract = {Imperative Programmierung (lateinisch imperare ‚anordnen‘, ‚befehlen‘) ist ein Programmierparadigma, nach dem „ein Programm aus einer Folge von Anweisungen besteht, die vorgeben, in welcher Reihenfolge was vom Computer getan werden soll“.Die imperative Programmierung ist das am längsten bekannte Programmierparadigma. Diese Vorgehensweise war, bedingt durch den Sprachumfang früherer Programmiersprachen, ehemals die klassische Art des Programmierens. Sie liegt dem Entwurf von vielen Programmiersprachen, zum Beispiel {ALGOL}, {BASIC}, Fortran, Pascal, Ada, {PL}/I, Cobol, C und allen Assemblersprachen zugrunde.Abweichende Bezeichnungen: In der Literatur wird dieses Entwicklungskonzept zum Teil auch „imperativ/prozedural“, „algorithmisch“ oder auch „zustandsorientiert“ genannt. Auch die Bezeichnung „prozedurale Programmierung“ wird zum Teil synonym verwendet, was jedoch abweichend auch mit „Verwendung von Prozeduren“ definiert wird.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-01-24},
	langid = {german},
	note = {Page Version {ID}: 219505017},
	file = {Snapshot:files/219/Imperative_Programmierung.html:text/html},
}

@inreference{noauthor_strukturierte_2021,
	title = {Strukturierte Programmierung},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Strukturierte_Programmierung&oldid=212983400},
	abstract = {Strukturierte Programmierung ist ein programmiersprachenübergreifendes Programmierparadigma, aus den 1960er Jahren, also noch vor der Softwarekrise. Es beinhaltet zum einen die baumartige Zerlegung eines Programms in Teilprogramme (Prozeduren) und enthält somit das Paradigma der prozeduralen Programmierung. Zudem verlangt die strukturierte Programmierung auf der untersten Ebene die Beschränkung auf lediglich drei Kontrollstrukturen:

Sequenz (hintereinander auszuführende Programmanweisungen)
Auswahl/Selektion (Verzweigung)
Wiederholung/Iteration (Schleifen)Die bekannteste Konsequenz dieses Prinzips ist die Vermeidung oder – abhängig von der Programmiersprache – der eingeschränkte und standardisierte Einsatz der Sprunganweisung, des {GOTO}. Das Ergebnis der häufigen Verwendung dieser Anweisungen wird häufig abfällig als Spaghetticode bezeichnet. 
Durch die konsequente Implementierung von Teilprogrammen mit lokaler Sichtbarkeit von Identifikatoren und Kontrollstrukturen vermeiden strukturierte Programme Codewiederholungen, was Vorteile bei der Suche von Programmfehlern mit sich bringt, die Programme kürzer und übersichtlicher macht und daher die Wartung von Software vereinfacht.
Strukturierte Programmierung ist heute in fast allen Bereichen, in denen professionell Software entwickelt wird, eine Selbstverständlichkeit. Die neueren Programmierparadigmen wie generative Programmierung, aspektorientierte Programmierung oder objektorientierte Programmierung bauen auf der strukturierten Programmierung auf und erweitern oder ergänzen diese.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2021-06-15},
	langid = {german},
	note = {Page Version {ID}: 212983400},
	file = {Snapshot:files/221/Strukturierte_Programmierung.html:text/html},
}

@inreference{noauthor_prozedurale_2021,
	title = {Prozedurale Programmierung},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Prozedurale_Programmierung&oldid=214023278},
	abstract = {Prozedurale Programmierung ist ein Programmierparadigma, nach dem Computerprogramme entwickelt werden können. Die Bezeichnung ist nicht eindeutig; in der Literatur wird sie für verschiedene Bedeutungen verwendet:

als Erweiterung des imperativen Paradigmas um den Ansatz, Algorithmen in überschaubare Teile zu zerlegen, die anhand einer definierten Schnittstelle aufrufbar sind.
innerhalb des imperativen Paradigmas als Gegenstück zur objektorientierten {ProgrammierungVereinzelt} wird prozedurale Programmierung auch als Synonym zur imperativen Programmierung an sich oder zur strukturierten Programmierung verstanden.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2021-07-19},
	langid = {german},
	note = {Page Version {ID}: 214023278},
	file = {Snapshot:files/223/Prozedurale_Programmierung.html:text/html},
}

@inreference{noauthor_evaluation_2022,
	title = {Evaluation strategy},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=Evaluation_strategy&oldid=1109984435},
	abstract = {In a programming language, an evaluation strategy is a set of rules for evaluating expressions. The term is often used to refer to the more specific notion of a parameter-passing strategy that defines the kind of value that is passed to the function for each parameter (the binding strategy) and whether to evaluate the parameters of a function call, and if so in what order (the evaluation order). The notion of reduction strategy is distinct, although some authors conflate the two terms and the definition of each term is not widely agreed upon.To illustrate, executing a function call f(a,b) may first evaluate the arguments a and b, store the results in references or memory locations ref\_a and ref\_b, then evaluate the function's body with those references passed in. This gives the function the ability to look up the argument values, to modify them via assignment as if they were local variables, and to return values via the references. This is the call-by-reference evaluation strategy.Evaluation strategy is specified by the programming language definition, and is not a function of any specific implementation. The calling convention defines implementation-specific parameter passing details.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-09-12},
	langid = {english},
	note = {Page Version {ID}: 1109984435},
}

@inreference{noauthor_funktionsprototyp_2020,
	title = {Funktionsprototyp},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Funktionsprototyp&oldid=196075270},
	abstract = {Als Funktionsprototyp oder Funktionskopf bezeichnet man in verschiedenen Programmiersprachen (vor allem C und C++) die Deklaration einer Funktion – inklusive Angaben über Anzahl und Typ der Parameter und Typ des Rückgabewertes – getrennt von ihrer Implementierung (Definition). Man spricht auch ungenau von der Vorausdeklaration (englisch: forward declaration, oft falsch als „Vorwärtsdeklaration“ übersetzt) einer Funktion, diese muss aber nicht in jedem Fall einen vollwertigen Funktionsprototypen darstellen. Beispiel: int funktion(); wäre in C eine gültige Vorausdeklaration, aber kein Prototyp, da keinerlei Angaben über Funktionsparameter gemacht werden. Jede Definition einer Funktion liefert hingegen automatisch immer auch eine Prototypdeklaration für nachfolgenden Programmcode.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2020-01-22},
	langid = {german},
	note = {Page Version {ID}: 196075270},
	file = {Snapshot:files/226/Funktionsprototyp.html:text/html},
}

@inreference{noauthor_deklaration_2022,
	title = {Deklaration (Programmierung)},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Deklaration_(Programmierung)&oldid=224245160},
	abstract = {In der Informatik und Programmierung ist eine Deklaration die Festlegung von Dimension, Bezeichner, Datentyp und weiteren Aspekten einer Variable oder eines Unterprogramms. Durch die Deklaration wird dem Übersetzer (Compiler oder Interpreter) diese Variable bzw. dieses Unterprogramm bekannt gemacht; es ist damit möglich, diese an anderen Stellen im selben Quelltext zu verwenden.
Häufig werden die Ausdrücke Deklaration und Definition mit der allgemeinen Bedeutung „Daten/Datenstrukturen/Datentypen festlegen/beschreiben“ als Synonyme verwendet. Beispiele siehe „eigene Datentypen definieren“ in, „definierte Variable“ in oder „definieren einer Klasse“ in Klasse.
Programmiersprachenabhängig werden diese Begriffe jedoch zum Teil auch unterschiedlich verwendet. So werden zum Beispiel in Haskell per Deklaration auch Funktionen spezifiziert, in den Programmiersprachen C++ und C wird dies ‚Definition‘ genannt. ‚Definition‘ wird dabei als Sonderfall der Deklaration verstanden. Bei Variablen spricht man von Definition, wenn der Übersetzer Code erzeugt, der entweder statisch (im Datensegment) oder dynamisch (zur Laufzeit) Speicherplatz für diese Variable reserviert. Bei Unterprogrammen spricht man von Definition, wenn an dieser Stelle der Quelltext des Unterprogramms angegeben ist. Die Deklaration eines Unterprogramms ohne Definition wird auch oft als Prototyp bezeichnet.
Bei der Referenzierung einer deklarierten (nicht definierten) Variable bzw. Unterprogrammes überprüft der Linker, dass die Variable bzw. das Unterprogramm an anderer Stelle definiert wurde und verknüpft die Referenzen mit der Definition.
Erst nach der Deklaration kann einer Variablen ein Ausdruck zugewiesen werden. Neben der expliziten Deklaration gibt es in einigen Programmiersprachen (z. B. Fortran, {BASIC}, {PL}/I) aber auch die Möglichkeit einer impliziten Deklaration von Variablen: In diesem Fall führt das erste Auftreten einer Variablen zu einer automatischen Typzuordnung.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-07-05},
	langid = {german},
	note = {Page Version {ID}: 224245160},
	file = {Snapshot:files/230/Deklaration_(Programmierung).html:text/html},
}

@inreference{noauthor_variable_2022,
	title = {Variable (Programmierung)},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Variable_(Programmierung)&oldid=225592766},
	abstract = {In der Programmierung ist eine Variable ein abstrakter Behälter für einen Wert, der bei der Ausführung eines Computerprogramm auftritt. Im Normalfall wird eine Variable im Quelltext durch einen Namen bezeichnet und hat eine Adresse im Speicher des Computers.
Der durch eine Variable repräsentierte Wert und gegebenenfalls auch die Größe kann – im Unterschied zu einer Konstante – zur Laufzeit des Rechenprozesses verändert werden.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-08-24},
	langid = {german},
	note = {Page Version {ID}: 225592766},
	file = {Snapshot:files/232/Variable_(Programmierung).html:text/html},
}

@inreference{noauthor_interpreter_2022,
	title = {Interpreter},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Interpreter&oldid=223748000},
	abstract = {Als Interpreter wird ein Computerprogramm bezeichnet, das eine Abfolge von Anweisungen anscheinend direkt ausführt, wobei das Format der Anweisungen vorgegeben ist. Der Interpreter liest dazu eine oder mehrere Quelldateien ein, analysiert diese und führt sie anschließend Anweisung für Anweisung aus, indem er den dafür vorgesehenen Programmcode (eventuell über Zwischenschritte schließlich als Maschinencode für das jeweilige Computersystem) direkt ausführt. Interpreter sind deutlich langsamer als Compiler, bieten im Allgemeinen jedoch eine bessere Fehleranalyse.Interpreter werden sowohl bei Programmiersprachen als auch bei Computerprogrammen sowie Kommandozeileninterpreter verwendet.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-06-16},
	langid = {german},
	note = {Page Version {ID}: 223748000},
	file = {Snapshot:files/234/Interpreter.html:text/html},
}

@inreference{noauthor_compiler_2022,
	title = {Compiler},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Compiler&oldid=225542576},
	abstract = {Ein Compiler (auch Kompilierer; von englisch compile ‚zusammentragen‘ bzw. lateinisch compilare ‚aufhäufen‘) ist ein Computerprogramm, das Quellcodes einer bestimmten Programmiersprache in eine Form übersetzt, die von einem Computer (direkter) ausgeführt werden kann. Daraus entsteht ein mehr oder weniger direkt ausführbares Programm. Davon zu unterscheiden sind Interpreter, etwa für frühe Versionen von {BASIC}, die keinen Maschinencode erzeugen.
Teils wird zwischen den Begriffen Übersetzer und Compiler unterschieden. Ein Übersetzer übersetzt ein Programm aus einer formalen Quellsprache in ein semantisches Äquivalent in einer formalen Zielsprache. Compiler sind spezielle Übersetzer, die Programmcode aus problemorientierten Programmiersprachen, sogenannten Hochsprachen, in ausführbaren Maschinencode einer bestimmten Architektur oder einen Zwischencode (Bytecode, p-Code oder .{NET}-Code) überführen. Diese Trennung zwischen den Begriffen Übersetzer und Compiler wird nicht in allen Fällen vorgenommen.
Der Vorgang der Übersetzung wird auch als Kompilierung oder Umwandlung (bzw. mit dem entsprechenden Verb) bezeichnet. Das Gegenteil, also die Rückübersetzung von Maschinensprache in Quelltext einer bestimmten Programmiersprache, wird Dekompilierung und entsprechende Programme Decompiler genannt.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-08-22},
	langid = {german},
	note = {Page Version {ID}: 225542576},
	file = {Snapshot:files/236/Compiler.html:text/html},
}

@inreference{noauthor_maschinensprache_2022,
	title = {Maschinensprache},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Maschinensprache&oldid=223307867},
	abstract = {Eine Maschinensprache, wie sie bei Maschinencode bzw. nativem Code verwendet wird, ist eine Programmiersprache, bei der die Instruktionen, die vom Prozessor ausgeführt werden sollen, als formale Sprachelemente festgelegt sind. Aufgrund ihrer Nähe zur Hardware wird sie auch verallgemeinernd als die „Programmiersprache eines Computers“ bezeichnet. Umfang und Syntax der Maschinenbefehle sind im Befehlssatz definiert und abhängig vom Prozessortyp. Maschinensprache wird meistens als Binärcode oder vereinfacht mithilfe von Hexadezimalzahlen dargestellt.
Ein Maschinenbefehl ist hierbei eine Anweisung an den Prozessor, eine Operation durchzuführen, beispielsweise eine Addition oder einen Wertevergleich. Jede funktionelle Leistung eines Prozessors ist daher Ergebnis der Ausführung von Maschinencode, eines in Maschinensprache vorliegenden Programms.
Programme in Maschinensprache werden üblicherweise nicht vom Programmierer direkt erzeugt, sondern unter Nutzung einer höheren Programmiersprache oder einer Assemblersprache, wobei erst mithilfe eines Compilers bzw. Assemblers ausführbarer Maschinencode entsteht. Wird von „Programmierung in Maschinensprache“ gesprochen, ist damit manchmal fälschlicherweise die Programmierung in Assemblersprache gemeint. Bei der Ausführung durch Interpreter werden dagegen die Maschinenbefehle beim Programmstart oder während der Laufzeit erzeugt.
Manchmal werden Ausdrücke wie „Maschinencode, Maschinensprache, Binärcode, nativer Code, Programmcode“ synonym verwendet. Sie können jedoch zwei unterschiedliche Bedeutungen haben:

Für die typisierende Bezeichnung des verwendeten Codes als Syntaxbestimmung. Beispiel: „Quellcode (für die Programmiersprache {XYZ})“
Für den Programmcode eines bestimmten Programms. Beispiel „Binärcode (für Programm {ABC})“},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-05-31},
	langid = {german},
	note = {Page Version {ID}: 223307867},
	file = {Snapshot:files/238/Maschinensprache.html:text/html},
}

@inreference{noauthor_cross_2022,
	title = {Cross compiler},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=Cross_compiler&oldid=1095178458},
	abstract = {A cross compiler is a compiler capable of creating executable code for a platform other than the one on which the compiler is running.  For example, a compiler that runs on a {PC} but generates code that runs on an Android smartphone is a cross compiler.
A cross compiler is useful to compile code for multiple platforms from one development host. Direct compilation on the target platform might be infeasible, for example on embedded systems with limited computing resources.
Cross compilers are distinct from source-to-source compilers. A cross compiler is for cross-platform software generation of machine code, while a source-to-source compiler translates from one coding language to another in text code. Both are programming tools.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-06-26},
	langid = {english},
	note = {Page Version {ID}: 1095178458},
	file = {Snapshot:files/240/Cross_compiler.html:text/html},
}

@inreference{noauthor_syntax_2022-1,
	title = {Syntax},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Syntax&oldid=221516032},
	abstract = {Unter Syntax (altgriechisch σύνταξις syntaxis, von σύν syn ‚zusammen‘ und τάξις taxis ‚Ordnung, Reihenfolge‘) versteht man allgemein ein Regelsystem zur Kombination elementarer Zeichen zu zusammengesetzten Zeichen in natürlichen oder künstlichen Zeichensystemen. Die Zusammenfügungsregeln der Syntax stehen hierbei den Interpretationsregeln der Semantik gegenüber.
Insbesondere versteht man unter Syntax die Satzlehre, ein Teilgebiet der Grammatik natürlicher Sprachen, das die Zusammenfügung von Wörtern bzw. Wortgruppen zu Sätzen (Satzbau) auf Basis grammatikalischer Gesetzmäßigkeiten (etwa einer bestimmten vorgeschriebenen Satzstellung) behandelt bzw. den Sätzen zugrunde liegende regelmäßige Muster (Satzstruktur) beschreibt. Die Syntax wird in der Regel unterschieden von der linguistischen Morphologie, die den inneren Aufbau der Wörter behandelt, obwohl die Übergänge zwischen beiden Bereichen fließend sein können.
Der Ausdruck Syntax wird für natürliche und formale Sprachen verwendet. Das Verhältnis zwischen natürlicher und formaler Syntax wird unterschiedlich gesehen. Für den Logiker Richard Montague (Universal Grammar, 1970) bestand kein prinzipieller Unterschied.
Ebenso wie der Begriff Grammatik kann sich der Begriff Syntax auf die Struktureigenschaften von Zeichensystemen selbst oder auf die theoretisch-wissenschaftliche Beschreibung dieser Struktureigenschaften beziehen.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-03-26},
	langid = {german},
	note = {Page Version {ID}: 221516032},
}

@inreference{noauthor_semantik_2022,
	title = {Semantik},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Semantik&oldid=225429979},
	abstract = {Semantik (von altgriechisch σημαίνειν sēmaínein, deutsch ‚bezeichnen, ein Zeichen geben‘), auch Bedeutungslehre, ist eine der drei Disziplinen der Semiotik, der wissenschaftlichen Betrachtung von Zeichen. Die Semantik behandelt die verschiedenen Beziehungen zwischen Zeichen und Bezeichnetem, vor allem für sprachliche Zeichen. Mit dieser Einschränkung ist sie Teil der Linguistik, aber sie kann sich auch mit Zeichen und Symbolen aller Art, etwa auch von Artefakten oder Kunstwerken befassen. Innerhalb der Semiotik hat abgrenzend die Syntaktik die interne Struktur sprachlicher und anderer Zeichensysteme zum Gegenstand und die Pragmatik ist die Theorie der Zeichenverwendung. Eine klaren Abgrenzung ist aus verschiedenen Gründen umstritten. Allgemein ist die Semantik die Wissenschaft der Bedeutung.
Die exakte Fixierung einer Bedeutung insbesondere von Sätzen, Satzteilen, Wörtern oder Wortteilen natürlicher oder formaler Sprachen ist Gegenstand der formalen Semantik.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-08-18},
	langid = {german},
	note = {Page Version {ID}: 225429979},
	file = {Snapshot:files/243/Semantik.html:text/html},
}

@inreference{noauthor_chomsky-hierarchie_2022,
	title = {Chomsky-Hierarchie},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Chomsky-Hierarchie&oldid=225920254},
	abstract = {Chomsky-Hierarchie, gelegentlich Chomsky-Schützenberger-Hierarchie (benannt nach dem Linguisten Noam Chomsky und dem Mathematiker Marcel Schützenberger), ist ein Begriff aus der Theoretischen Informatik. Sie ist eine Hierarchie von Klassen formaler Grammatiken, die formale Sprachen erzeugen, und wurde 1956 erstmals von Noam Chomsky beschrieben. Die Hierarchiestufen unterscheiden sich darin, wie rigide die Einschränkungen für die Form zulässiger Produktionsregeln auf der jeweiligen Stufe sind; bei Typ-0-Grammatiken sind sie uneingeschränkt, bei höheren Stufen fortschreitend stärker beschränkt.
Grammatiken niedrigeren Typs sind erzeugungsmächtiger als die höherer Typen. Eine Sprache, die von einer Grammatik des Typs k erzeugt wird, heißt eine Sprache des Typs k. Neben die Chomsky-Hierarchie der Grammatiken tritt in diesem Sinne eine Chomsky-Hierarchie der Sprachen.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-09-05},
	langid = {german},
	note = {Page Version {ID}: 225920254},
	file = {Snapshot:files/245/Chomsky-Hierarchie.html:text/html},
}

@inreference{noauthor_syntaxbaum_2022,
	title = {Syntaxbaum},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Syntaxbaum&oldid=222977877},
	abstract = {Ein Syntax-, Ableitungs- oder Parsebaum ist ein Begriff aus der theoretischen Informatik und der Linguistik. Er bezeichnet eine hierarchische Darstellung der Zergliederung eines Textes.  Syntaxbäume werden sowohl als Hilfsmittel zur graphischen Visualisierung der Zerlegung eingesetzt als auch, in Form einer Datenstruktur, zur Darstellung dieser Zergliederung für die maschinelle Weiterverarbeitung z. B. in einem Compiler oder Übersetzer.
Die verschiedenen Bezeichnungen werden in der Literatur nicht einheitlich verwendet. Formal präzise definiert ist nur der Terminus Ableitungsbaum, der sich auf den Begriff der Ableitung stützt. Andere Bezeichnungen für verschiedenartige Bäume können dann, wie unten beschrieben, bei Bedarf technisch näher definiert werden.
Anders als in der Informatik, in der Sprachen auch den technischen Möglichkeiten folgend definiert werden können, findet die Linguistik bei der Behandlung natürlicher Sprachen schwierigere Voraussetzungen vor, vor allem weil die Reihenfolge der Bestandteile in einem Satz variieren kann.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-05-18},
	langid = {german},
	note = {Page Version {ID}: 222977877},
	file = {Snapshot:files/247/Syntaxbaum.html:text/html},
}

@inreference{noauthor_wortproblem_2022,
	title = {Wortproblem (Berechenbarkeitstheorie)},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Wortproblem_(Berechenbarkeitstheorie)&oldid=220669412},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-02-28},
	langid = {german},
	note = {Page Version {ID}: 220669412},
	file = {Snapshot:files/249/Wortproblem_(Berechenbarkeitstheorie).html:text/html},
}

@online{noauthor_217_nodate-1,
	title = {2.1.7 Vorrangregeln und Assoziativität},
	url = {https://www.tu-chemnitz.de/urz/archiv/kursunterlagen/C/kap2/vorrang.htm},
	urldate = {2022-09-13},
	file = {2.1.7 Vorrangregeln und Assoziativität:files/253/vorrang.html:text/html},
}

@inreference{noauthor_operatorrangfolge_2022,
	title = {Operatorrangfolge},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Operatorrangfolge&oldid=223157277},
	abstract = {Als Operatorrangfolge, -wertigkeit, -priorität oder -präzedenz bezeichnet man in Mathematik, Logik und Informatik eine definierte Halbordnung, in der die Operatoren eines in Infix-Schreibweise vorliegenden Ausdrucks auszuwerten sind.
Die Operatorrangfolge ist keine Totalordnung, sondern eine Halbordnung, weil es keine strikte Reihenfolge zwischen allen Operatoren geben muss. Es können auch mehrere Operatoren auf demselben Rang stehen. Zum Beispiel ist in der Arithmetik der Rang von Multiplikation und Division gleich, aber höher als der Rang von Addition und Subtraktion („Punktrechnung vor Strichrechnung“).
Eine Klammerung bietet die Möglichkeit der Bevorrangung eines Teilstücks einer Formel: Der eingeklammerte, also von einem Klammerpaar „( ... )“ eingeschlossene Bereich ist rechnerisch zuerst auszuführen und durch das entsprechende Teilergebnis zu ersetzen. Die Klammerung muss die Operatoren samt ihren nötigen Operanden enthalten. Wird also 
  
    
      
        a
        ⋅
        (
        b
        +
        c
        )
      
    
    \{{\textbackslash}displaystyle a{\textbackslash}cdot (b+c)\}
   notiert, ist zuerst der Klammerausdruck zu berechnen, also die Summe 
  
    
      
        (
        b
        +
        c
        )
      
    
    \{{\textbackslash}displaystyle (b+c)\}
   zu bilden, bevor 
  
    
      
        a
      
    
    \{{\textbackslash}displaystyle a\}
   mit dieser Summe multipliziert wird.
Durch die Rangfolge kann man explizite Klammerungen sparen. So ist in der Arithmetik 
  
    
      
        a
        +
        b
        ⋅
        c
      
    
    \{{\textbackslash}displaystyle a+b{\textbackslash}cdot c\}
   gleichbedeutend mit 
  
    
      
        a
        +
        (
        b
        ⋅
        c
        )
      
    
    \{{\textbackslash}displaystyle a+(b{\textbackslash}cdot c)\}
  , weil der Multiplikationsoperator einen höheren Rang hat. Für andere Anwendungen dieser Operatorsymbole können jedoch andere Rangordnungen definiert sein.
Bei nicht kommutativen Operatoren bedarf es noch zusätzlicher Konvention darüber, ob gleichrangige Teilausdrücke von links nach rechts oder rechts nach links auszuwerten sind, um die Rechenreihenfolge eindeutig festzulegen.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-05-25},
	langid = {german},
	note = {Page Version {ID}: 223157277},
	file = {Snapshot:files/255/Operatorrangfolge.html:text/html},
}

@inreference{noauthor_lexical_2022,
	title = {Lexical analysis},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=Lexical_analysis&oldid=1104772145},
	abstract = {In computer science, lexical analysis, lexing or tokenization is the process of converting a sequence of characters (such as in a computer program or web page) into a sequence of lexical tokens (strings with an assigned and thus identified meaning). A program that performs lexical analysis may be termed a lexer, tokenizer, or scanner, although scanner is also a term for the first stage of a lexer. A lexer is generally combined with a parser, which together analyze the syntax of programming languages, web pages, and so forth.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-08-16},
	langid = {english},
	note = {Page Version {ID}: 1104772145},
	file = {Snapshot:files/257/Lexical_analysis.html:text/html},
}

@inreference{noauthor_token_2014,
	title = {Token (Übersetzerbau)},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Token_(%C3%9Cbersetzerbau)&oldid=133785837},
	abstract = {Ein Token (Art.: „das“; Pl.: ‚Tokens‘) ist eine Zeichenkette, der von einer formalen Grammatik ein Typ zugewiesen wird. Das Token bildet die lexikalische Grundeinheit für den Parser. Ein Token entspricht in der Grammatik des Parsers einem Terminalsymbol.
Im trivialen Fall sind Tokens die Zeichen der ursprünglichen Eingabe: Zum Beispiel der Buchstabe A wird als Token vom Typ A erkannt. Mehrere Zeichen können im Zuge einer lexikalischen Analyse zu Tokens zusammengefasst werden. Die einem Token zu Grunde liegende Zeichenkette heißt Lexem. Beispiele:},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2014-09-06},
	langid = {german},
	note = {Page Version {ID}: 133785837},
	file = {Snapshot:files/259/Token_(Übersetzerbau).html:text/html},
}

@inreference{noauthor_lexikalische_2022,
	title = {Lexikalische Analyse},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Lexikalische_Analyse&oldid=225542512},
	abstract = {Lexikalische Analyse ist in der Informatik die Zerlegung einer Zeichenkette (z. B.  Quelltext) in eine Folge von logisch zusammengehörigen Einheiten, sogenannte Token. Ein Computerprogramm, das eine lexikalische Analyse durchführt, wird Lexer, Tokenizer oder lexikalischer Scanner genannt. Ein Lexer ist meist Teil eines Compilers und wird als erster Schritt in der Analysephase ausgeführt. Das Ergebnis des Lexers wird im nächsten Schritt von einem Parser weiterverarbeitet.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-08-22},
	langid = {german},
	note = {Page Version {ID}: 225542512},
	file = {Snapshot:files/261/Lexikalische_Analyse.html:text/html},
}

@inreference{noauthor_literal_2021,
	title = {Literal},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Literal&oldid=216440695},
	abstract = {Ein Literal ist ein spezieller Bestandteil einer formalen Sprache.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2021-10-17},
	langid = {german},
	note = {Page Version {ID}: 216440695},
	file = {Snapshot:files/263/Literal.html:text/html},
}

@inreference{noauthor_parser_2022,
	title = {Parser},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Parser&oldid=225991691},
	abstract = {Ein Parser [ˈpɑːʁzɐ] (englisch to parse, „analysieren“, bzw. lateinisch pars, „Teil“; im Deutschen gelegentlich auch Zerteiler) ist ein Computerprogramm, das in der Informatik für die Zerlegung und Umwandlung einer Eingabe in ein für die Weiterverarbeitung geeigneteres Format zuständig ist. Häufig werden Parser eingesetzt, um im Anschluss an den Analysevorgang die Semantik der Eingabe zu erschließen und daraufhin Aktionen durchzuführen.
Im Vergleich zu einem Recognizer, der die Eingabe analysiert und ausgibt, ob diese im Sinne der Vorgaben richtig oder falsch ist, gibt der Parser die Analyse einer Eingabe in einer gewünschten Form aus und erzeugt zusätzlich Strukturbeschreibungen.
Die Syntaxanalyse (Parsing) findet auch außerhalb der Informatik Anwendung, z. B. bei der Untersuchung der Struktur von natürlichen Sprachen. In der Grammatik würde die Syntaxanalyse eines Satzes dem Zerlegen des Satzes in seine grammatikalischen Bestandteile (Syntax) entsprechen. Siehe dazu Linguistik.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-09-08},
	langid = {german},
	note = {Page Version {ID}: 225991691},
	file = {Snapshot:files/265/Parser.html:text/html},
}

@inreference{noauthor_recognizer_2021,
	title = {Recognizer},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Recognizer&oldid=216435306},
	abstract = {Ein Recognizer (engl. to recognize: „erkennen“), auch Erkenner, ist in der Informatik ein bestimmtes abstraktes Maschinenmodell, ein sogenannter Automat. Dieser Automat stellt auf Grundlage einer formalen Grammatik fest, ob ein konkretes Wort Element einer formalen Sprache ist oder nicht. Die Sprache wird dabei durch die zugrundegelegte formale Grammatik definiert bzw. erzeugt. Der Recognizer entscheidet nur, ob ein Eingabetext hinsichtlich der Vorgaben „richtig“ oder „falsch“ ist; das unterscheidet ihn von einem Parser, der zusätzlich die analysierte grammatikalische Struktur beschreiben und ausgeben kann. Ein typisches Beispiel für einen Recognizer in der Automatentheorie ist der Kellerautomat.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2021-10-17},
	langid = {german},
	note = {Page Version {ID}: 216435306},
	file = {Snapshot:files/267/Recognizer.html:text/html},
}

@inreference{noauthor_ausdruck_2021,
	title = {Ausdruck (Programmierung)},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Ausdruck_(Programmierung)&oldid=212957642},
	abstract = {Ein Ausdruck ist in vielen Programmiersprachen ein Konstrukt, das gemäß einer gegebenen Semantik in Bezug auf einen Kontext ausgewertet werden kann, also einen Wert liefert.
In vielen formalen Sprachen sind Ausdrücke eines der wichtigsten Konstrukte, wenn nicht gar das einzige. Einige Beispiele:

Arithmetische Ausdrücke
2*3; 2(x − a); x2 = 2x; y= sin(x); usw.
Aussagenlogische Ausdrücke
a und b; wenn b dann a; a oder nicht b; usw.
Prädikatenlogische Ausdrücke
wenn verheiratet(A, B) dann verheiratet(B, A); wenn Mensch(A) dann (Mann(A) oder Frau(A)); usw.Ausdrücke in Programmiersprachen

Literale (Konstanten): 2, 3.14, … (Aber auch Zeichenketten (Strings) und Zeichen: "Hallo Welt", 'c', …)
Variablen: x, {betragInEuro}, {wochentagsNummer}, …
Funktionen: sin(phi), random(), {aktMonatsNummer}(), …
Operationen: 2*3, 2(x - a), x{\textasciicircum}3, cos(2*x + 3.14), …
Kombinierte Ausdrücke, zum Teil auch mit Zuweisungen oder Ausdrucksanweisungen: x++, --y, y = x = 2*z, y = sin(x), …Neben den Ausdrücken sind in vielen formalen Sprachen Deklarationen wichtig, die den Kontext für die Ausdrücke definieren. Diese werden manchmal (vor allem in funktionalen Programmiersprachen und Skriptsprachen) selbst ebenfalls als Ausdrücke betrachtet.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2021-06-14},
	langid = {german},
	note = {Page Version {ID}: 212957642},
	file = {Snapshot:files/269/Ausdruck_(Programmierung).html:text/html},
}

@inreference{noauthor_anweisung_2022,
	title = {Anweisung (Programmierung)},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Anweisung_(Programmierung)&oldid=222957636},
	abstract = {Als Anweisung oder Statement (aus englisch statement entlehnt) wird in der Informatik im Bereich der Programmierung ein zentrales Element vieler imperativer Programmiersprachen bezeichnet. Die Programme derartiger Sprachen setzen sich hauptsächlich aus einer oder mehreren Anweisungen zusammen. Eine Anweisung stellt eine in der Syntax einer Programmiersprache formulierte einzelne Vorschrift dar, die im Rahmen der Abarbeitung des Programms auszuführen ist. Wie eine Anweisung syntaktisch auszusehen hat, wird durch die jeweilige Programmiersprache oder deren Spezifikation festgelegt und ist innerhalb eines Programms (üblicherweise) nicht änderbar.
In der maschinennahen Programmierung werden Anweisungen häufig auch als Befehl, Instruktion (aus englisch instruction) oder Kommando (aus englisch command) bezeichnet.
Anweisungen sind üblicherweise Zuweisungen, Kontrollanweisungen (wie Sprünge, Schleifen und bedingte Anweisungen) und Prozeduraufrufe. Abhängig von der Programmiersprache sind teilweise auch Zusicherungen, Deklarationen, Klassen- und Funktionsdefinitionen Anweisungen.
Im Gegensatz zu Ausdrücken haben Anweisungen nicht immer einen Wert. Einige Anweisungen können jedoch auch Ausdrücke sein, so z. B. Zuweisungen, Inkrementoperatoren oder Funktionsaufrufe. Umgekehrt sind viele Ausdruckstypen wie etwa Vergleiche oder arithmetische Ausdrücke keine syntaktisch vollständigen Anweisungen.
Sequenzen von Anweisungen werden häufig in Blöcken zusammengefasst.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-05-17},
	langid = {german},
	note = {Page Version {ID}: 222957636},
	file = {Snapshot:files/271/Anweisung_(Programmierung).html:text/html},
}

@inreference{noauthor_metasyntax_2022,
	title = {Metasyntax},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=Metasyntax&oldid=1082973684},
	abstract = {In logic and computer science, a metasyntax describes the allowable structure and composition of phrases and sentences of a metalanguage, which is used to describe either a natural language or a computer programming language. Some of the widely used formal metalanguages for computer languages are Backus–Naur form ({BNF}), extended Backus–Naur form ({EBNF}), Wirth syntax notation ({WSN}), and augmented Backus–Naur form ({ABNF}).
These metalanguages have their own metasyntax each composed of terminal symbols, nonterminal symbols, and metasymbols. A terminal symbol, such as a word or a token, is a stand-alone structure in a language being defined. A nonterminal symbol represents a syntactic category, which defines one or more valid phrasal or sentence structure consisted of an n-element subset. Metasymbols provide syntactic information for denotational purposes in a given metasyntax. Terminals, nonterminals, and metasymbols do not apply across all metalanguages.
Typically, the metalanguage for token-level languages (formally called "regular languages") does not have nonterminals because nesting is not an issue in these regular languages. English, as a metalanguage for describing certain languages, does not contain metasymbols since all explanation could be done using English expression. There are only certain formal metalanguages used for describing recursive languages (formally called context-free languages) that have terminals, nonterminals, and metasymbols in their metasyntax.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-04-16},
	langid = {english},
	note = {Page Version {ID}: 1082973684},
	file = {Snapshot:files/273/Metasyntax.html:text/html},
}

@inreference{noauthor_metasprache_2020,
	title = {Metasprache},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Metasprache&oldid=202231184},
	abstract = {Eine Metasprache ist eine „Sprache über Sprache“. Die Sprache, über die eine Metasprache spricht, ist die zugehörige Objektsprache.Meta kommt aus dem Griechischen (μετά) und bedeutet unter anderem so viel wie ‚hinter‘, ‚über‘.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2020-07-26},
	langid = {german},
	note = {Page Version {ID}: 202231184},
	file = {Snapshot:files/275/Metasprache.html:text/html},
}

@inreference{noauthor_backus-naur-form_2022,
	title = {Backus-Naur-Form},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Backus-Naur-Form&oldid=223748201},
	abstract = {Die Backus-Naur-Form oder Backus-Normalform (kurz {BNF}) ist eine kompakte formale Metasprache zur Darstellung kontextfreier Grammatiken (Typ-2-Grammatiken in der Chomsky-Hierarchie). Hierzu zählt die Syntax gängiger höherer Programmiersprachen. Sie wird auch für die Notation von Befehlssätzen und Kommunikationsprotokollen verwendet.
Ursprünglich war sie nach John W. Backus benannt, später wurde sie (auf Anregung von Donald E. Knuth) auch nach Peter Naur benannt. Beide waren Pioniere der Informatik, die sich mit der Erstellung der Algol-60-Regeln und insbesondere mit der Kunst des Compilerbaus beschäftigten. Durch die Backus-Naur-Form im Algol 60 Report wurde es erstmals möglich, die Syntax einer Programmiersprache formal exakt, also ohne die Ungenauigkeiten natürlicher Sprachen, darzustellen.
Es gibt viele Varianten der Backus-Naur-Form. Die erweiterte Backus-Naur-Form ({EBNF}) ist eine gebräuchliche Variante, die unter anderem eine kompakte Notation von sich wiederholenden Elementen erlaubt. Für Syntaxdefinitionen in Internetnormen wird überwiegend die angereicherte Backus-Naur-Form ({ABNF}) verwendet.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-06-16},
	langid = {german},
	note = {Page Version {ID}: 223748201},
	file = {Snapshot:files/277/Backus-Naur-Form.html:text/html},
}

@inreference{noauthor_earley_2022-1,
	title = {Earley parser},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=Earley_parser&oldid=1090848932},
	abstract = {In computer science, the Earley parser is an algorithm for parsing strings that belong to a given context-free language, though (depending on the variant) it may suffer problems with certain nullable grammars. The algorithm, named after its inventor, Jay Earley, is a chart parser that uses dynamic programming; it is mainly used for parsing in computational linguistics. It was first introduced in his dissertation in 1968 (and later appeared in an abbreviated, more legible, form in a journal).
Earley parsers are appealing because they can parse all context-free languages, unlike {LR} parsers and {LL} parsers, which are more typically used in compilers but which can only handle restricted classes of languages.  The Earley parser executes in cubic time in the general case 
  
    
      
        
          O
        
        (
        
          n
          
            3
          
        
        )
      
    
    \{{\textbackslash}displaystyle \{O\}(n{\textasciicircum}\{3\})\}
  , where n is the length of the parsed string, quadratic time for unambiguous grammars 
  
    
      
        
          O
        
        (
        
          n
          
            2
          
        
        )
      
    
    \{{\textbackslash}displaystyle \{O\}(n{\textasciicircum}\{2\})\}
  , and linear time for all deterministic context-free grammars. It performs particularly well when the rules are written left-recursively.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-05-31},
	langid = {english},
	note = {Page Version {ID}: 1090848932},
	file = {Snapshot:files/279/Earley_parser.html:text/html},
}

@inreference{noauthor_entartung_2021,
	title = {Entartung (Informatik)},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Entartung_(Informatik)&oldid=215501841},
	abstract = {Eine Datenstruktur wird als entartet bezeichnet, wenn sie final einen Zustand angenommen hat, in der sie anders als vor der Entartung nachteilig wirkt. Dies kann aufgrund ungünstiger Eingabedaten geschehen.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2021-09-11},
	langid = {german},
	note = {Page Version {ID}: 215501841},
	file = {Snapshot:files/281/Entartung_(Informatik).html:text/html},
}

@inreference{noauthor_symboltabelle_2013,
	title = {Symboltabelle},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Symboltabelle&oldid=118290830},
	abstract = {In der Informatik ist eine Symboltabelle eine von Übersetzerprogrammen wie Compiler oder Interpreter verwendete Datenstruktur, die jedem Symbol im Quellcode Angaben wie die Stelle des Auftretens, den Datentyp oder einen Zeiger auf eine Struktur im Speicher zuordnet. Der Begriff Symbol wird in diesem Zusammenhang im Sinne von Bezeichner verwendet.
Meist wird eine Symboltabelle durch eine Hashtabelle implementiert. Sie kann entweder nur temporär während der Übersetzung aufgebaut werden oder auch länger vorgehalten werden, um eine spätere Fehlersuche etwa mit einem Debugger zu erleichtern.
In Programmiersprachen wie Lisp spielt die Symboltabelle eine darüber hinausgehende Rolle, weil sie auch die zentrale Datenstruktur des Laufzeitsystems darstellt.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2013-05-07},
	langid = {german},
	note = {Page Version {ID}: 118290830},
	file = {Snapshot:files/283/Symboltabelle.html:text/html},
}

@inreference{noauthor_aufrufstapel_2021,
	title = {Aufrufstapel},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Aufrufstapel&oldid=210008829},
	abstract = {Unter einem Aufrufstapel (englisch call stack, procedure stack) versteht man in der Softwaretechnik und Informatik einen besonders genutzten Stapelspeicher, der zur Laufzeit eines Programms den Zustand der gerade aufgerufenen Unterprogramme enthält. Er ist vorgesehener Bestandteil der meisten Prozessorarchitekturen und seine Benutzung wird daher von speziellen Instruktionen und Registern unterstützt oder sogar erfordert. Als Stack Machine (engl. für Stapelmaschine, nicht zu verwechseln mit Kellerautomat) wird eine Klasse von Prozessorarchitekturen bezeichnet, die gänzlich um einen Aufrufstapel herum konstruiert sind, demgegenüber verwenden Registermaschinen zwar üblicherweise einen Aufrufstapel, sind jedoch nicht ausschließlich auf seine Nutzung angewiesen. Die Verwaltung des Aufrufstapels wird in Hochsprachen üblicherweise abstrahiert und stattdessen von Compiler und Betriebssystem übernommen. Anders als beim paradigmatischen Stapelspeicher sind die Zugriffsmöglichkeiten auf den Aufrufstapel in vielen Architekturen jedoch nicht auf das oberste Element beschränkt und die Klassifizierung als Stapel ergibt sich aus der Verwendung als Stapelspeicher für Rücksprungadressen von Unterprogrammen. Zudem ist der Inhalt des Speichers sehr inhomogen und verknüpft Nutzdaten mit Verwaltungsdaten.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2021-03-20},
	langid = {german},
	note = {Page Version {ID}: 210008829},
	file = {Snapshot:files/285/Aufrufstapel.html:text/html},
}

@inreference{noauthor_bezeichner_2020,
	title = {Bezeichner},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Bezeichner&oldid=201100315},
	abstract = {Ein Bezeichner (selten auch Identifikator, englisch identifier) ist in der Informatik ein Identifikator, mit dem ein Programmierer in einem Programm ein Objekt, z. B. einen Datentyp, eine Variable oder eine Funktion, eindeutig benennt. Daher muss ein Bezeichner innerhalb eines Namensraums eindeutig sein, es sei denn, die Programmiersprache erlaubt das Überladen.
In der Regel werden für Bezeichner Literale (aus Buchstaben) verwendet. Auch Numerale (aus Ziffern) sind üblich, erlauben aber keine gute Mnemonik, diese wird mit einer Kombination einer Zeichenfolge aus Buchstaben und Nummern erreicht. Zur Typenkennzeichnung werden häufig Präfixe oder Suffixe benutzt.
Programmiersprachen verwenden verschiedene Konventionen für Bezeichner, z. B. welche (Sonder-)Zeichen darin vorkommen dürfen, ob Groß- und Kleinschreibung unterschieden wird und wie lang der Bezeichner maximal sein darf. Darüber hinaus können weitergehende Benennungsregeln angewendet werden, die zum Teil öffentlich definiert sind (zum Beispiel in der Ungarischen Notation) oder die als Unternehmensstandard, den Programmierstil betreffend, festgelegt wurden.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2020-06-18},
	langid = {german},
	note = {Page Version {ID}: 201100315},
	file = {Snapshot:files/287/Bezeichner.html:text/html},
}

@inreference{noauthor_label_2022,
	title = {Label (Programmierung)},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Label_(Programmierung)&oldid=218756487},
	abstract = {Ein Label (zu Deutsch: Sprungmarke) in einem Quellcode eines Computerprogramms ist eine durch einen Bezeichner eindeutig gekennzeichnete Marke, die üblicherweise als Sprungziel dient.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-01-03},
	langid = {german},
	note = {Page Version {ID}: 218756487},
	file = {Snapshot:files/289/Label_(Programmierung).html:text/html},
}

@inreference{noauthor_assemblersprache_2022,
	title = {Assemblersprache},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Assemblersprache&oldid=225449545},
	abstract = {Eine Assemblersprache, kurz auch Assembler genannt (von englisch to assemble  ‚zusammenfügen‘), ist eine Programmiersprache, die auf den Befehlsvorrat eines bestimmten Computertyps (d. h. dessen Prozessorarchitektur) ausgerichtet ist.
Assemblersprachen bezeichnet man deshalb als maschinenorientierte Programmiersprachen und – als Nachfolger der direkten Programmierung mit Zahlencodes – als Programmiersprachen der zweiten Generation: Anstelle eines Binärcodes der Maschinensprache können Befehle und deren Operanden durch leichter verständliche mnemonische Symbole in Textform (z. B. „{MOVE}“), Operanden z. T. als symbolische Adresse (z. B. „{PLZ}“), notiert und dargestellt werden.Der Quelltext eines Assemblerprogramms wird mit Hilfe einer Übersetzungssoftware (Assembler oder Assemblierer) in Maschinencode übersetzt. Dagegen übersetzt in höheren Programmiersprachen (Hochsprachen, dritte Generation) ein sogenannter Compiler abstraktere (komplexere, nicht auf den Prozessor-Befehlssatz begrenzte) Befehle in den Maschinencode der gegebenen Zielarchitektur – oder in eine Zwischensprache.Umgangssprachlich werden die Ausdrücke „Maschinensprache“ und „Assembler(sprache)“ häufig synonym verwendet.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-08-19},
	langid = {german},
	note = {Page Version {ID}: 225449545},
	file = {Snapshot:files/291/Assemblersprache.html:text/html},
}

@inreference{noauthor_assembler_2021,
	title = {Assembler},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Assembler&oldid=212253092},
	abstract = {Assembler steht für:

Assembler (Informatik), ein Computerprogramm, das eine Assemblersprache in Maschinensprache übersetzt
Assemblersprache, eine Klasse von Programmiersprachen für Computer
Assembler (Bioinformatik), ein Computerprogramm, das eine Genomassemblierung durchführt
Assembler (Nanotechnologie), ein Roboter, der Atome und Moleküle {manipuliertSiehe} auch:},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2021-05-23},
	langid = {german},
	note = {Page Version {ID}: 212253092},
	file = {Snapshot:files/293/Assembler.html:text/html},
}

@inreference{noauthor_objektcode_2019,
	title = {Objektcode},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Objektcode&oldid=194427842},
	abstract = {Objektcode ist ein Zwischenergebnis eines Compiler- bzw. Übersetzungsvorgangs von einem Computerprogramm. 
Einfache Compiler können diesen Schritt überspringen.
Der Objektcode besteht hauptsächlich aus Maschinencode für die Architektur, für die das Programm übersetzt wurde. Er enthält üblicherweise kompakten und vorgeparsten Code und oft benutzte Programmbibliotheken, die dann mit anderen Objektdateien gebunden werden.
Das Format eines Objektcodes ist abhängig von Programmiersprache, Compiler und der Maschine. Nach dem Erstellen von Objektcode erfolgt normalerweise das Linken, welches als Ergebnis das fertige, ausführbare Programm liefert.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2019-11-27},
	langid = {german},
	note = {Page Version {ID}: 194427842},
	file = {Snapshot:files/295/Objektcode.html:text/html},
}

@inreference{noauthor_linker_2022,
	title = {Linker (Computerprogramm)},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Linker_(Computerprogramm)&oldid=225065452},
	abstract = {Unter einem Linker oder Binder (auch: „Bindelader“) versteht man ein Computerprogramm, das einzelne Programmmodule zu einem ausführbaren Programm zusammenstellt (verbindet). Auf {IBM}-Großrechnersystemen wird der Linker linkage editor (englisch) genannt.Die meisten Programme enthalten Bestandteile oder Module, die in anderen Programmen Verwendung finden können. Mehrere kompilierte Module mit Funktionen (so genannte Objektdateien) können zu Funktionsbibliotheken (Programmbibliotheken) zusammengefasst werden. Der Code wird durch den Linker zum Hauptprogramm hinzugefügt, falls die entsprechende Funktion benötigt wird.
Um ein Programmmodul in einem anderen Programm verwenden zu können, müssen die symbolischen Adressen der Funktionen und Variablen des Moduls in Speicheradressen umgewandelt werden. Diese Aufgabe übernimmt der Linker. Der Linkvorgang erfolgt nach der Kompilierung und ist meistens der letzte Arbeitsschritt zur Erstellung eines Programms. Man unterscheidet generell zwischen statischem und dynamischem Linken.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-08-04},
	langid = {german},
	note = {Page Version {ID}: 225065452},
	file = {Snapshot:files/297/Linker_(Computerprogramm).html:text/html},
}

@inreference{noauthor_rekursiver_2021,
	title = {Rekursiver Abstieg},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Rekursiver_Abstieg&oldid=217102237},
	abstract = {Rekursiver Abstieg (englisch: recursive descent) ist eine Technik aus dem Compilerbau, die auf direkte Weise (d. h. ohne Tabelle) einen Top-Down-Parser implementiert. Sie zeichnet sich durch geringe Komplexität aus, das Verwenden eines Parsergenerators ist nicht nötig.
Bei diesem Verfahren kommt jedem Nichtterminalsymbol eine Prozedur zu, welche die Produktionsregel zu diesem Symbol charakterisiert. Erlauben die Produktionsregeln eine Rekursion, dann rufen sich daher auch diese Prozeduren wechselseitig rekursiv auf.
Ein rekursiver Abstieg kann Backtracking enthalten. Ein Verzicht darauf ist jedoch garantiert, wenn eine {LL}(k)-Grammatik für die zu parsende Sprache gegeben ist. Im Folgenden wird der häufige Fall 
  
    
      
        k
        =
        1
      
    
    \{{\textbackslash}displaystyle k=1\}
   angenommen.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2021-11-08},
	langid = {german},
	note = {Page Version {ID}: 217102237},
	file = {Snapshot:files/299/Rekursiver_Abstieg.html:text/html},
}

@inreference{noauthor_llk-grammatik_2015,
	title = {{LL}(k)-Grammatik},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=LL(k)-Grammatik&oldid=143824732},
	abstract = {Dieser Artikel setzt Vorkenntnisse im Bereich Theoretische Informatik und Compilerbau voraus.

Eine {LL}(k)-Grammatik (im Gegensatz zu {LF}(k)-Grammatik auch schwache {LL}(k)-Grammatik) ist eine spezielle kontextfreie Grammatik, welche die Grundlage eines {LL}(k)-Parsers bildet.
Eine kontextfreie Grammatik heißt {LL}(k)-Grammatik für eine natürliche Zahl k, wenn jeder Ableitungsschritt eindeutig durch die nächsten k Symbole der Eingabe (Lookahead) bestimmt ist. Das bedeutet, die Frage, welches Nichtterminalsymbol mit welcher Regel als Nächstes expandiert werden soll, kann eindeutig mit Hilfe der nächsten k Symbole der Eingabe bestimmt werden.
Generell gilt, je größer k gewählt wird, umso mächtiger wird die Sprachklasse, wobei die Ausdrucksstärke von kontextfreien Grammatiken nie erreicht wird. Damit gibt es kontextfreie Sprachen, die für kein k von einer {LL}(k)-Grammatik erzeugt werden.

  
    
      
        
          
            L
          
        
        (
        
          L
          L
        
        (
        1
        )
        )
        ⊊
        
          
            L
          
        
        (
        
          L
          L
        
        (
        2
        )
        )
        ⊊
        ⋯
        ⊊
        
          
            L
          
        
        (
        
          L
          L
        
        (
        k
        )
        )
        ⊊
        
          
            L
          
        
        (
        
          L
          R
        
        (
        1
        )
        )
        =
        
          
            L
          
        
        (
        
          D
          P
          D
          A
        
        )
      
    
    \{{\textbackslash}displaystyle \{{\textbackslash}mathcal \{L\}\}({\textbackslash}mathrm \{{LL}\} (1)){\textbackslash}subsetneq \{{\textbackslash}mathcal \{L\}\}({\textbackslash}mathrm \{{LL}\} (2)){\textbackslash}subsetneq {\textbackslash}dots {\textbackslash}subsetneq \{{\textbackslash}mathcal \{L\}\}({\textbackslash}mathrm \{{LL}\} (k)){\textbackslash}subsetneq \{{\textbackslash}mathcal \{L\}\}({\textbackslash}mathrm \{{LR}\} (1))=\{{\textbackslash}mathcal \{L\}\}({\textbackslash}mathrm \{{DPDA}\} )\}
  
Dabei steht {DPDA} für die deterministischen Kellerautomaten. Diese können genau die deterministisch kontextfreien Sprachen erkennen.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2015-07-07},
	langid = {german},
	note = {Page Version {ID}: 143824732},
	file = {Snapshot:files/301/LL(k)-Grammatik.html:text/html},
}

@inreference{noauthor_graph_2022,
	title = {Graph coloring},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=Graph_coloring&oldid=1110085555},
	abstract = {In graph theory, graph coloring is a special case of graph labeling; it is an assignment of labels traditionally called "colors" to elements of a graph subject to certain constraints. In its simplest form, it is a way of coloring the vertices of a graph such that no two adjacent vertices are of the same color; this is called a vertex coloring. Similarly, an edge coloring assigns a color to each edge so that no two adjacent edges are of the same color, and a face coloring of a planar graph assigns a color to each face or region so that no two faces that share a boundary have the same color.
Vertex coloring is often used to introduce graph coloring problems, since other coloring problems can be transformed into a vertex coloring instance. For example, an edge coloring of a graph is just a vertex coloring of its line graph, and a face coloring of a plane graph is just a vertex coloring of its dual. However, non-vertex coloring problems are often stated and studied as-is. This is partly pedagogical, and partly because some problems are best studied in their non-vertex form, as in the case of edge coloring.
The convention of using colors originates from coloring the countries of a map, where each face is literally colored. This was generalized to coloring the faces of a graph embedded in the plane. By planar duality it became coloring the vertices, and in this form it generalizes to all graphs. In mathematical and computer representations, it is typical to use the first few positive or non-negative integers as the "colors". In general, one can use any finite set as the "color set". The nature of the coloring problem depends on the number of colors but not on what they are.
Graph coloring enjoys many practical applications as well as theoretical challenges. Beside the classical types of problems, different limitations can also be set on the graph, or on the way a color is assigned, or even on the color itself. It has even reached popularity with the general public in the form of the popular number puzzle Sudoku. Graph coloring is still a very active field of research.
Note: Many terms used in this article are defined in Glossary of graph theory.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-09-13},
	langid = {english},
	note = {Page Version {ID}: 1110085555},
	file = {Snapshot:files/303/Graph_coloring.html:text/html},
}

@inreference{noauthor_register_2022,
	title = {Register allocation},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=Register_allocation&oldid=1104778380},
	abstract = {In compiler optimization, register allocation is the process of assigning local automatic variables and expression results to a limited number of processor registers.
Register allocation can happen over a basic block (local register allocation), over a whole function/procedure (global register allocation), or across function boundaries traversed via call-graph (interprocedural register allocation). When done per function/procedure the calling convention may require insertion of save/restore around each call-site.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-08-16},
	langid = {english},
	note = {Page Version {ID}: 1104778380},
	file = {Snapshot:files/305/Register_allocation.html:text/html},
}

@inreference{noauthor_kontrollflussgraph_2022,
	title = {Kontrollflussgraph},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Kontrollflussgraph&oldid=221536594},
	abstract = {Ein Kontrollflussgraph ist ein Begriff aus der Informatik und bezeichnet einen gerichteten Graphen, der dazu dient, den Kontrollfluss eines Computerprogramms zu beschreiben. Sie werden unter anderem zur Programmoptimierung eingesetzt.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-03-27},
	langid = {german},
	note = {Page Version {ID}: 221536594},
	file = {Snapshot:files/307/Kontrollflussgraph.html:text/html},
}

@inreference{noauthor_kontrollfluss_2021,
	title = {Kontrollfluss},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Kontrollfluss&oldid=210777251},
	abstract = {Der Kontrollfluss oder Programmablauf bezeichnet in der Informatik die zeitliche Abfolge der einzelnen Befehle eines Computerprogramms. Der Kontrollfluss eines Programms ist gewöhnlich durch die Reihenfolge der Befehle innerhalb des Programms vorgegeben, jedoch erlauben Kontrollstrukturen von der sequenziellen Abarbeitung des Programms abzuweichen. Die Abarbeitungsreihenfolge der einzelnen Befehle, welche das Programm vorgibt, wird von Kontrollflussabhängigkeiten festgelegt: Ein einzelner Befehl wird entweder dann ausgeführt, wenn der unmittelbar vorhergehende Befehl abgearbeitet und der Programmzähler inkrementiert wurde oder wenn ein Sprungbefehl auf die entsprechende Stelle im Speicher zeigt und dem Programmzähler durch den Sprungbefehl ein neuer Wert zugewiesen wird. Beide Kontrollflussabhängigkeiten müssen bei der parallelen Ausführung von Befehlen des Programms berücksichtigt werden.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2021-04-10},
	langid = {german},
	note = {Page Version {ID}: 210777251},
	file = {Snapshot:files/309/Kontrollfluss.html:text/html},
}

@inreference{noauthor_control_2022,
	title = {Control flow analysis},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=Control_flow_analysis&oldid=1070083426},
	abstract = {In computer science, control-flow analysis ({CFA}) is a static-code-analysis technique for determining the control flow of a program. The control flow is expressed as a control-flow graph ({CFG}). For both functional programming languages and object-oriented programming languages, the term {CFA}, and elaborations such as k-{CFA}, refer to specific algorithms that compute control flow.For many imperative programming languages, the control flow of a program is explicit in a program's source code.  As a result, interprocedural control-flow analysis implicitly usually refers to a static analysis technique for determining the receiver(s) of function or method calls in computer programs written in a higher-order programming language. For example, in a programming language with higher-order functions like Scheme, the target of a function call may not be explicit: in the isolated expression

it is unclear to which procedure f may refer.  A control-flow analysis must consider where this expression could be invoked and what argument it may receive to determine the possible targets.
Techniques such as abstract interpretation, constraint solving, and type systems may be used for control-flow analysis.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-02-05},
	langid = {english},
	note = {Page Version {ID}: 1070083426},
	file = {Snapshot:files/311/Control_flow_analysis.html:text/html},
}

@inreference{noauthor_bootstrapping_2022,
	title = {Bootstrapping (compilers)},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=Bootstrapping_(compilers)&oldid=1107502446},
	abstract = {In computer science, bootstrapping is the technique for producing a self-compiling compiler – that is, a compiler (or assembler) written in the source programming language that it intends to compile. An initial core version of the compiler (the bootstrap compiler) is generated in a different language (which could be assembly language); successive expanded versions of the compiler are developed using this minimal subset of the language. The problem of compiling a self-compiling compiler has been called the chicken-or-egg problem in compiler design, and bootstrapping is a solution to this problem.Many compilers for many programming languages are bootstrapped, including compilers for {BASIC}, {ALGOL}, C, C\#, D, Pascal, {PL}/I, Haskell, Modula-2, Oberon, {OCaml}, Common Lisp, Scheme, Go, Java, Elixir, Rust, Python, Scala, Nim, Eiffel, {TypeScript}, Vala, Zig and more.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-08-30},
	langid = {english},
	note = {Page Version {ID}: 1107502446},
	file = {Snapshot:files/313/Bootstrapping_(compilers).html:text/html},
}

@inreference{noauthor_regulare_2021,
	title = {Reguläre Grammatik},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Regul%C3%A4re_Grammatik&oldid=210508085},
	abstract = {Eine reguläre Grammatik ist in der Informatik eine formale Grammatik vom Typ 3 der Chomsky-Hierarchie. Die von solchen Grammatiken erzeugten Sprachen heißen reguläre Sprachen.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2021-04-03},
	langid = {german},
	note = {Page Version {ID}: 210508085},
}

@inreference{noauthor_kontextfreie_2021,
	title = {Kontextfreie Grammatik},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Kontextfreie_Grammatik&oldid=213960399},
	abstract = {In der Theorie der formalen Sprachen ist eine kontextfreie Grammatik (englisch context-free grammar, {CFG}) eine formale Grammatik, die nur solche Ersetzungsregeln enthält, bei denen immer genau ein Nichtterminalsymbol auf eine beliebig lange Folge von Nichtterminal- und Terminalsymbolen abgeleitet wird. Die Ersetzungsregeln haben also die Form 
  
    
      
        V
        →
        w
      
    
    \{{\textbackslash}displaystyle V{\textbackslash}rightarrow w\}
   (mit Nichtterminalsymbol 
  
    
      
        V
      
    
    \{{\textbackslash}displaystyle V\}
   und Zeichenkette 
  
    
      
        w
      
    
    \{{\textbackslash}displaystyle w\}
   bestehend aus Nichtterminal- und/oder Terminalsymbolen).
Weil die linke Seite einer Regel nur aus einem einzigen Nichtterminalsymbol 
  
    
      
        V
      
    
    \{{\textbackslash}displaystyle V\}
   besteht, hängt ihre Anwendbarkeit auf eine Zeichenkette nur davon ab, ob das Nichtterminalsymbol 
  
    
      
        V
      
    
    \{{\textbackslash}displaystyle V\}
   in der Zeichenkette vorkommt, nicht aber davon, in welchem Kontext es sich befindet, d. h. welche Zeichen links und/oder rechts davon stehen. Die Regeln sind also kontextfrei.
Die kontextfreien Grammatiken sind identisch mit den Typ-2-Grammatiken der Chomsky-Hierarchie.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2021-07-17},
	langid = {german},
	note = {Page Version {ID}: 213960399},
}

@online{noauthor_grammar_nodate-2,
	title = {Grammar Reference — Lark documentation},
	url = {https://lark-parser.readthedocs.io/en/latest/grammar.html},
	urldate = {2022-09-13},
	file = {Grammar Reference — Lark documentation:files/318/grammar.html:text/html},
}

@inreference{noauthor_mehrdeutige_2013,
	title = {Mehrdeutige Grammatik},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Mehrdeutige_Grammatik&oldid=115943783},
	abstract = {Existieren bzgl. einer formalen Grammatik für ein Wort mehrere Rechtsableitungen oder Linksableitungen, bzw. gibt es zu einem Wort der Grammatik zwei verschiedene Rechts- oder zwei verschiedene Linksableitungsbäume, die nicht isomorph zueinander sind, dann heißt diese Grammatik mehrdeutig.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2013-03-27},
	langid = {german},
	note = {Page Version {ID}: 115943783},
	file = {Snapshot:files/320/Mehrdeutige_Grammatik.html:text/html},
}

@inreference{noauthor_operatorrangfolge_2022-1,
	title = {Operatorrangfolge},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://de.wikipedia.org/w/index.php?title=Operatorrangfolge&oldid=223157277},
	abstract = {Als Operatorrangfolge, -wertigkeit, -priorität oder -präzedenz bezeichnet man in Mathematik, Logik und Informatik eine definierte Halbordnung, in der die Operatoren eines in Infix-Schreibweise vorliegenden Ausdrucks auszuwerten sind.
Die Operatorrangfolge ist keine Totalordnung, sondern eine Halbordnung, weil es keine strikte Reihenfolge zwischen allen Operatoren geben muss. Es können auch mehrere Operatoren auf demselben Rang stehen. Zum Beispiel ist in der Arithmetik der Rang von Multiplikation und Division gleich, aber höher als der Rang von Addition und Subtraktion („Punktrechnung vor Strichrechnung“).
Eine Klammerung bietet die Möglichkeit der Bevorrangung eines Teilstücks einer Formel: Der eingeklammerte, also von einem Klammerpaar „( ... )“ eingeschlossene Bereich ist rechnerisch zuerst auszuführen und durch das entsprechende Teilergebnis zu ersetzen. Die Klammerung muss die Operatoren samt ihren nötigen Operanden enthalten. Wird also 
  
    
      
        a
        ⋅
        (
        b
        +
        c
        )
      
    
    \{{\textbackslash}displaystyle a{\textbackslash}cdot (b+c)\}
   notiert, ist zuerst der Klammerausdruck zu berechnen, also die Summe 
  
    
      
        (
        b
        +
        c
        )
      
    
    \{{\textbackslash}displaystyle (b+c)\}
   zu bilden, bevor 
  
    
      
        a
      
    
    \{{\textbackslash}displaystyle a\}
   mit dieser Summe multipliziert wird.
Durch die Rangfolge kann man explizite Klammerungen sparen. So ist in der Arithmetik 
  
    
      
        a
        +
        b
        ⋅
        c
      
    
    \{{\textbackslash}displaystyle a+b{\textbackslash}cdot c\}
   gleichbedeutend mit 
  
    
      
        a
        +
        (
        b
        ⋅
        c
        )
      
    
    \{{\textbackslash}displaystyle a+(b{\textbackslash}cdot c)\}
  , weil der Multiplikationsoperator einen höheren Rang hat. Für andere Anwendungen dieser Operatorsymbole können jedoch andere Rangordnungen definiert sein.
Bei nicht kommutativen Operatoren bedarf es noch zusätzlicher Konvention darüber, ob gleichrangige Teilausdrücke von links nach rechts oder rechts nach links auszuwerten sind, um die Rechenreihenfolge eindeutig festzulegen.},
	booktitle = {Wikipedia},
	urldate = {2022-09-13},
	date = {2022-05-25},
	langid = {german},
	note = {Page Version {ID}: 223157277},
	file = {Snapshot:files/322/Operatorrangfolge.html:text/html},
}

@online{ooijen_answer_2012,
	title = {Answer to "One or two {UART} stop bits?"},
	url = {https://electronics.stackexchange.com/a/29949},
	shorttitle = {Answer to "One or two {UART} stop bits?},
	titleaddon = {Electrical Engineering Stack Exchange},
	author = {Ooijen, Wouter van},
	urldate = {2022-11-13},
	date = {2012-04-15},
	file = {Snapshot:files/324/one-or-two-uart-stop-bits.html:text/html},
}
